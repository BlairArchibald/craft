commit 40373e7d7286b2ff702865b90902cb85ac6aca24
Author: Mike Lam <lam@cs.umd.edu>
Date:   Thu Dec 9 13:51:24 2010 -0500

    Adds BPatch_binaryEdit::addIgnoredLibrary
    
    This allows the user to specify particular shared libraries that they do not
    wish to be rewritten when writeFile is called.

diff --git a/dyninstAPI/h/BPatch_binaryEdit.h b/dyninstAPI/h/BPatch_binaryEdit.h
index 3840346..b80f829 100644
--- a/dyninstAPI/h/BPatch_binaryEdit.h
+++ b/dyninstAPI/h/BPatch_binaryEdit.h
@@ -83,6 +83,8 @@ class BPATCH_DLL_EXPORT BPatch_binaryEdit : public BPatch_addressSpace {
     std::map<std::string, BinaryEdit *> llBinEdits;
     BinaryEdit *origBinEdit;
 
+    std::vector<std::string> ignoredLibs;
+
     std::vector<BinaryEdit *> rtLib;
 
     BPatch_binaryEdit(const char *path, bool openDependencies);
@@ -150,6 +152,14 @@ class BPATCH_DLL_EXPORT BPatch_binaryEdit : public BPatch_addressSpace {
 
     API_EXPORT_VIRT(Int, (libname, reload),
     BPatch_module *, loadLibrary,(const char *libname, bool reload = false));
+
+
+    // BPatch_binaryEdit::addIgnoredLibrary
+    //
+    //  Add a library name to the "do not include when rewriting" list
+    
+    API_EXPORT_V(Int, (libname),
+                void, addIgnoredLibrary, (const char *libname));
 };    
 
 #endif /* BPatch_binaryEdit_h_ */
diff --git a/dyninstAPI/src/BPatch_binaryEdit.C b/dyninstAPI/src/BPatch_binaryEdit.C
index 838971b..f42340a 100644
--- a/dyninstAPI/src/BPatch_binaryEdit.C
+++ b/dyninstAPI/src/BPatch_binaryEdit.C
@@ -243,20 +243,37 @@ bool BPatch_binaryEdit::writeFileInt(const char * outFile)
    }
 
 
-   if( !origBinEdit->writeFile(outFile) ) return false;
-
-   std::map<std::string, BinaryEdit *>::iterator curBinEdit;
-   for (curBinEdit = llBinEdits.begin(); curBinEdit != llBinEdits.end(); curBinEdit++) {
-     BinaryEdit *bin = (*curBinEdit).second;
-     if (bin == origBinEdit)
-       continue;
-     if (!bin->isDirty())
-       continue;
-
-     std::string newname = bin->getMappedObject()->fileName();
-     if( !bin->writeFile(newname) ) return false;
-   }
-   return ret;
+    // write original executable/library
+    if( !origBinEdit->writeFile(outFile) ) return false;
+
+    // write any shared libraries
+    std::map<std::string, BinaryEdit *>::iterator curBinEdit;
+    std::vector<std::string>::iterator curLib;
+    bool skip;
+    for (curBinEdit = llBinEdits.begin(); curBinEdit != llBinEdits.end(); curBinEdit++) {
+       BinaryEdit *bin = (*curBinEdit).second;
+       if (bin == origBinEdit)
+          continue;
+       if (!bin->isDirty())
+          continue;
+
+       // skip any libraries specified using the addIgnoredLibrary call
+       skip = false;
+       std::string newname = bin->getMappedObject()->fileName();
+       for (curLib = ignoredLibs.begin(); curLib != ignoredLibs.end(); curLib++) {
+           if (*curLib == newname) {
+               skip = true;
+               break;
+           }
+       }
+       if (skip)
+           continue;
+
+       if( !bin->writeFile(newname) ) return false;
+    }
+
+
+    return ret;
 }
 
 bool BPatch_binaryEdit::getType()
@@ -340,6 +357,10 @@ BPatch_module *BPatch_binaryEdit::loadLibraryInt(const char *libname, bool deps)
    return getImage()->findOrCreateModule(obj->getDefaultModule());
 }
 
+void BPatch_binaryEdit::addIgnoredLibraryInt(const char *libname) {
+    ignoredLibs.push_back((std::string)libname);
+}
+
 // Here's the story. We may need to install a trap handler for instrumentation
 // to work in the rewritten binary. This doesn't play nicely with trap handlers
 // that the binary itself registers. So we're going to replace every call to
