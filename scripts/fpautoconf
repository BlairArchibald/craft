#!/usr/bin/ruby
#
# fpautoconf
#
# Generate floating-point precision configurations for a target binary, and test
# them. Assemble a final recommended configuration.
#
# Mike Lam, UMD
# February 2012
#

# needed for opening stderr as well as stdin/stdout
# when spawning new system processes
require 'open3.rb'

# needed for object serialization
require 'yaml.rb'

# needed for easier directory removal
require 'fileutils.rb'

#require 'rubygems'
#require 'inline'
 
# By Peter Cooper - http://www.rubyinside.com/
# Oodles of inspiration and examples from
# http://www-128.ibm.com/developerworks/linux/library/l-affinity.html
 
#class LinuxScheduler
    #inline do |builder|
        #builder.include '<sched.h>'
        #builder.include '<stdio.h>'
        #builder.c '
        #int _set_affinity(int cpu_id) {
            #cpu_set_t mask;
            #__CPU_ZERO(&mask);
            #__CPU_SET(cpu_id, &mask);
            #if(sched_setaffinity(getpid(), sizeof(mask), &mask ) == -1) {
                #printf("WARNING: Could not set CPU Affinity, continuing as-is\n");
                #return 0;
            #}
            #return 1;
        #}
        #'
    #end
 
    # cpu_id is 0-based, so for core/cpu 1 = 0, etc..
    #def self.set_affinity(cpu_id)
        #self.new._set_affinity(cpu_id.to_i)
    #end
#end
 
$STATUS_PASSED = "Success!"
$STATUS_FAILED = "FAILED!"
$STATUS_ERROR  = "ERROR!!!"

# {{{ main method
def main
    srand

    # global variables
    $craft_driver = "craft_driver"    # standard driver program name
    $stat_preferred = "s"       # preferred replacement status
    $stat_alternate = "d"       # replacement status if cannot be preferred
    $stat_ignored = "i"         # "cannot instrument" replacement status
    $stat_blank = " "           # "no result" replacement status
    $fortran_mode = false       # pass "-N" to fpinst
    $initial_cfg_fn = ""        # initial config filename (may be blank)
    $max_queue_length = 0       # track largest queue size (approximate)
    $is_status = false          # is this just a status thread?
    $is_worker = false          # is this the parent process or a worker?
    $workers = Hash.new         # worker proc info (pid => dirname)
    $status_buffer = ""         # buffer for output (keeps multiprocess output clean)
    $all_cfgs = Hash.new        # collection of all configs (key => cfg)
    $self_invoke = File.basename($0)

    # check command-line options
    if ARGV.size == 0 or ARGV.include?("-h") then
        puts "Usage:  #{$self_invoke} [options] <binary>        (parent process)"
        puts "          or"
        puts "        #{$self_invoke} -r                       (resume parent process)"
        puts "          or"
        puts "        #{$self_invoke} -w <id> <dir>            (worker process)"
        puts "          or"
        puts "        #{$self_invoke} clean                    (reset search)"
        puts "Valid options:"
        puts "   -c <file>      use <file> as initial base configuration"
        puts "   -d             debug mode (ignore->double instead of double->single)"
        puts "   -j <np>        spawn <np> worker threads"
        puts "   -N             enable Fortran mode (passes \"-N\" to fpinst)"
        exit
    end

    # cleaning mode
    if ARGV.size == 1 and ARGV[0] == "clean" then
        puts "Cleaning..."
        toDelete = Array.new
        Dir.glob("fpautoconf.*") do |fn| toDelete << fn end
        Dir.glob("*_worker*") do |fn| toDelete << fn end
        Dir.glob("*.cfg") do |fn| toDelete << fn end
        Dir.glob("*.log") do |fn| toDelete << fn end
        Dir.glob("final") do |fn| toDelete << fn end
        Dir.glob("best") do |fn| toDelete << fn end
        Dir.glob("passed") do |fn| toDelete << fn end
        Dir.glob("failed") do |fn| toDelete << fn end
        Dir.glob("aborted") do |fn| toDelete << fn end
        toDelete.each do |fn|
            FileUtils.rm_rf(fn)
        end
        puts "Done."
        exit
    end

    # status mode
    if ARGV.size == 1 and ARGV[0] == "status" then
        $is_status = true;
        ARGV.shift
    end

    # parse command-line options
    num_workers = 1
    begin
        opt = ARGV.shift
        if opt == "-r" then
        elsif opt == "-w" then
            # worker process
            $is_worker = true
            $worker_id = ARGV.shift
            $autoconf_path = ARGV.shift
        elsif opt == "-j" then
            # parallel: "-j 4" variant
            num_workers = ARGV.shift.to_i
        elsif opt =~ /^-j/ then
            # parallel: "-j4" variant
            num_workers = opt[2,opt.length-2].to_i
        elsif opt == "-d" then
            # debug mode
            $stat_preferred = "d"
            $stat_alternate = "i"
        elsif opt == "-c" then
            # initial configuration
            $initial_cfg_fn = ARGV.shift
        elsif opt == '-N' then
            # fortran mode
            $fortran_mode = true
        end
    end while ARGV.size > 0

    # set up environment and filenames
    if !$is_worker then
        $autoconf_path = Dir.getwd + "/"
    end
    $settings_fn = "#{$autoconf_path}fpautoconf.settings"
    $allconfigs_fn = "#{$autoconf_path}fpautoconf.allconfigs"
    $workqueue_fn = "#{$autoconf_path}fpautoconf.workqueue"
    $inproc_fn = "#{$autoconf_path}fpautoconf.inproc"
    $tested_fn = "#{$autoconf_path}fpautoconf.tested"
    $regexps_fn = "#{$autoconf_path}fpautoconf.regexps"
    $mainlog_fn = "#{$autoconf_path}fpautoconf.mainlog"
    $walltime_fn = "#{$autoconf_path}fpautoconf.walltime"
    $orig_config_name = "#{$autoconf_path}fpautoconf_orig.cfg"
    $final_config_name = "#{$autoconf_path}fpautoconf_final.cfg"
    $debug_config_name = "#{$autoconf_path}fpautoconf_debug.cfg"
    $final_path = "#{$autoconf_path}final/"
    $best_path = "#{$autoconf_path}best/"
    $passed_path = "#{$autoconf_path}passed/"
    $failed_path = "#{$autoconf_path}failed/"
    $aborted_path = "#{$autoconf_path}aborted/"

    # check for driver script
    if !File.exist?("#{$autoconf_path}#{$craft_driver}") then
        puts "No driver program \"craft_driver\" found."
        puts "Aborting."
        exit
    end

    if $is_status then

        overall_status = "not running"
        full = false
        if File.exist?($settings_fn) then
            begin
                load_all_configs false
                num_workers = Dir.glob("*_worker*").size
                elapsed = Time.now.to_f - $start_time.to_f
                overall_status = "initializing"
                overall_status = "running" if get_workqueue_length > 0
                overall_status = "finalizing" if File.exist?($final_path)
                if File.exist?($walltime_fn) then
                    overall_status = "DONE"
                    elapsed = IO.readlines($walltime_fn)[0].to_f
                end
                full = true
            rescue
                overall_status = "initializing"
            end
        end

        puts "==============================================="
        puts "                   CRAFT"
        if full then
            puts "    Application: #{"%25s" % $binary_name}"
            puts "    Fortran mode:  #{"%23s" % ($fortran_mode ? "Y" : "N")}"
            puts "    Worker threads:            #{"%11d" % num_workers}"
            puts "    Total configs tested:      #{"%11d" % get_tested_length}"
            puts "      Total passed:            #{"%11d" % get_regexps_length("passed")}"
            puts "      Total failed:            #{"%11d" % get_regexps_length("failed")}"
            puts "      Total aborted:           #{"%11d" % get_regexps_length("aborted")}"
            puts "    Current in-proc length:    #{"%11d" % get_inproc_length}"
            puts "    Current workqueue length:  #{"%11d" % get_workqueue_length}"
            puts "    Total elapsed walltime: #{"%14s" % format_time(elapsed)}"
        end
        puts "    Overall status:         #{"%14s" % overall_status}"
        puts "==============================================="
        if full then
            puts build_best_report.join("\n")
            puts "==============================================="
        end

        exit

    elsif $is_worker then

        # worker process
        #LinuxScheduler.set_affinity($worker_id+1)
        load_all_configs
        run_main_autoconf_loop
        puts "Worker finished.  [Empty queue]"

    else

        $binary_name = File.basename(opt)
        $binary_path = File.expand_path(opt)
        puts "CRAFT"
        puts "Autoconfiguring #{$binary_name} ..."
        puts "Working dir: #{$autoconf_path}"

        if !File.exist?($workqueue_fn) then
            # first invocation of this analysis; initialize everything
            initialize_autoconf
        else
            puts "Resuming previous analysis ..."
            load_all_configs
            #move_all_inproc_to_workqueue
        end

        # spawn workers
        num_workers.times do |i|
            puts "Spawning worker #{i} ..."
            worker_dir = "#{$autoconf_path + $binary_name}_#{Process.pid}_worker#{i}"
            if File.exist?(worker_dir) then
                FileUtils.rm_rf(worker_dir)
            end
            Dir.mkdir(worker_dir)
            job = fork do
                exec "cd #{worker_dir} && #{$self_invoke} -w #{i} #{$autoconf_path}"
            end
            $workers[job] = worker_dir
        end

        # main loop
        run_main_supervisor_loop

        # parent finalization
        finalize_autoconf

    end
end
# }}}

# {{{ SingleReplacementConfig
# stores single config info (mainly for serialization)
class SingleReplacementConfig
    attr_accessor :key              # unique config identifier
    attr_accessor :filename         # .cfg filename
    attr_accessor :type             # mod, func, bblk, insn
    attr_accessor :tag              # user-friendly short description
    attr_accessor :regexp           # config pattern for creating final config
    attr_accessor :ccount           # number of candidate fp instructions
    attr_accessor :rcount           # number of restricted (ignore/single/double) structures
    attr_accessor :children         # proper subset configs
    attr_accessor :initial          # value of initial replacement ('c','s','d','i',' ')
    def initialize(id, type, initial)
        @key = "#{type}_#{id}"
        @tag = "#{key}"
        @filename = "#{$binary_name}_#{key}.cfg"
        @type = type
        @children = Array.new
        @initial = initial
        if @type == "mod" then
            @regexp = Regexp.new("MODULE.*\"#{id}\"")
        elsif @type == "func" then
            @regexp = Regexp.new("FUNC #\\d+: 0x#{id}")
        elsif @type == "bblk" then
            @regexp = Regexp.new("BBLK #\\d+: 0x#{id}")
        elsif @type == "insn" then
            @regexp = Regexp.new("INSN #\\d+: 0x#{id}")
        else
            @regexp = //
        end
        if @type == "insn" && @initial == "c" then
            @ccount = 1
        else
            @ccount = 0
        end
        if @initial == "i" || @initial == "s" || @initial == "d" then
            @rcount = 1
        else
            @rcount = 0
        end
    end
end
# }}}

# {{{ initialize_autoconf
def initialize_autoconf

    # parent initialization
    $start_time = Time.now

    # create search config files
    File.new($settings_fn, "w").close
    File.new($allconfigs_fn, "w").close
    File.new($workqueue_fn, "w").close
    File.new($inproc_fn, "w").close
    File.new($tested_fn, "w").close
    File.new("#{$regexps_fn}-passed", "w").close
    File.new("#{$regexps_fn}-failed", "w").close
    File.new("#{$regexps_fn}-aborted", "w").close
    File.new($mainlog_fn, "w").close

    # initial performance run
    print "Performing baseline performance test ... "
    $stdout.flush
    passed = false
    $baseline_error = 0.0
    $baseline_runtime = 0
    cmd = "#{$autoconf_path}#{$craft_driver} #{$binary_path}"
    io_in, io_out, io_err = Open3.popen3(cmd)
    io_err.each_line do |line| end
    io_out.each_line do |line|
        if line =~ /status:\s*(pass|fail)/i then
            if $1 =~ /pass/i then
                passed = true
            end
        end
        if line =~ /error:\s*(.+)/i then
            $baseline_error = $1.to_f
        end
        if line =~ /time:\s*(.+)/i then
            $baseline_runtime = $1.to_i
        end
    end
    if !passed then
        puts "Baseline performance test failed verification!"
        puts "Aborting search."
        exit
    end
    puts " [Base error: #{$baseline_error}  walltime: #{format_time($baseline_runtime.to_f)}]"

    # generate initial configuration by calling fpconf
    # and initialize global data structures
    print "Generating initial configuration ... "
    $stdout.flush
    orig_cfg = File.open($orig_config_name, "w")
    if $initial_cfg_fn.length > 0 && File.exists?($initial_cfg_fn) then
        print "(using base: #{$initial_cfg_fn}) "
        $stdout.flush
        IO.foreach($initial_cfg_fn) do |io|
            io.each_line do |line|
                orig_cfg.puts line
            end
        end
    else
        IO.popen("fpconf #{$binary_path}") do |io|
            io.each_line do |line|
                orig_cfg.puts line
            end
        end
    end
    orig_cfg.close
    mod = nil
    func = nil
    bblk = nil
    IO.foreach($orig_config_name) do |io|
        io.each_line do |line|
            if line =~ /MODULE.*\"(.+)\"/ then
                mod = SingleReplacementConfig.new($1, "mod", line[1,1])
                $all_cfgs[mod.key] = mod
            end
            if line =~ /FUNC #\d+: 0x([0-9A-Fa-f]+) \"(.+)\"/ then
                func = SingleReplacementConfig.new($1, "func", line[1,1])
                func.tag = "func_#{$2}"
                $all_cfgs[func.key] = func
                mod.children << func.key if mod != nil
                mod.rcount  += func.rcount if mod != nil
            end
            if line =~ /BBLK #\d+: 0x([0-9A-Fa-f]+)/ then
                bblk = SingleReplacementConfig.new($1, "bblk", line[1,1])
                $all_cfgs[bblk.key] = bblk
                func.children << bblk.key if func != nil
                func.rcount += bblk.rcount if func != nil
                mod.rcount  += bblk.rcount if mod != nil
            end
            if line =~ /INSN #\d+: 0x([0-9A-Fa-f]+)/ then
                insn = SingleReplacementConfig.new($1, "insn", line[1,1])
                $all_cfgs[insn.key] = insn
                bblk.children << insn.key if bblk != nil
                bblk.ccount += insn.ccount if bblk != nil
                func.ccount += insn.ccount if func != nil
                mod.ccount  += insn.ccount if mod != nil
                bblk.rcount += insn.rcount if bblk != nil
                func.rcount += insn.rcount if func != nil
                mod.rcount  += insn.rcount if mod != nil
            end
        end
    end
    puts "done."

    # throw away empty configs
    to_delete = Array.new
    $all_cfgs.each_pair do |key, cfg|
        to_delete << key if cfg.ccount == 0
    end
    to_delete.each do |key|
        $all_cfgs.delete(key)
    end

    # save project config to file (for workers to load)
    puts "Total # of configurations: #{$all_cfgs.size}"
    save_all_configs

    # initialize work queue
    # start by trying all modules
    count = 0
    $all_cfgs.each_pair do |key, cfg|
        # FOR TESTING: limit to five
        #if cfg.type == "mod" && cfg.ccount > 0 && count < 5 then
        if cfg.type == "mod" && cfg.ccount > 0 &&
                (cfg.initial == " " || cfg.initial == "c") then
            puts "Adding config #{cfg.tag} to workqueue"
            add_to_workqueue(cfg.key)
            count += 1
        end
    end
    $max_queue_length = get_workqueue_length

    # create folders for saving configurations
    FileUtils.rm_rf($best_path)
    Dir.mkdir($best_path)
    FileUtils.rm_rf($passed_path)
    Dir.mkdir($passed_path)
    FileUtils.rm_rf($failed_path)
    Dir.mkdir($failed_path)
    FileUtils.rm_rf($aborted_path)
    Dir.mkdir($aborted_path)

end
# }}}

# {{{ run_main_autoconf_loop
def run_main_autoconf_loop
    key = get_next_workqueue_item

    # main search loop
    while !key.nil? && key != "" do

        add_to_inproc(key)

        # grab configuration object
        cfg = $all_cfgs[key]

        # queue status output
        queue_length = get_workqueue_length
        $status_buffer += "[Queue length: #{"%3d" % (queue_length+1)}]  "
        $max_queue_length = queue_length if queue_length > $max_queue_length

        puts "Testing config #{cfg.tag}: ccount=#{cfg.ccount} rcount=#{cfg.rcount}"

        if cfg.rcount == 0 && run_config(cfg) == $STATUS_PASSED then

            # this config passed

        else

            # add any children we need to test
            if (cfg.type == "mod"  && cfg.ccount >= 1) ||
               (cfg.type == "func" && cfg.ccount >= 1) ||
               (cfg.type == "bblk" && cfg.ccount >= 2) then
                cfg.children.each do |ckey|
                    child = $all_cfgs[ckey]
                    if child != nil && child.ccount > 0 &&
                            (child.initial == " " || child.initial == "c") then
                        puts "Adding config #{child.tag} to workqueue"
                        add_to_workqueue(ckey)
                    end
                end
            end

        end

        add_to_tested(key)
        remove_from_inproc(key)
        key = get_next_workqueue_item
    end

end
# }}}

# {{{ run_main_supervisor_loop
def run_main_supervisor_loop
    while get_workqueue_length > 0 or get_inproc_length > 0 do
        while get_workqueue_length > 0 do

            # restart any dead worker processes
            if !$is_worker && get_workqueue_length > 0 then
                $workers.each_pair do |job, dir|
                    cmd = "ps -o s= p #{job.to_i}"
                    stat = `#{cmd}`
                    stat.chomp!
                    if stat != "S" then
                        $workers.delete(job)
                        id = File.basename(dir)
                        if id =~ /worker(\d+)/ then
                            id = $1
                        else
                            id = id[$binary_name.length+1,id.length-$binary_name.length-1]
                        end
                        puts "Respawning worker #{id} ..."
                        FileUtils.rm_rf(dir)
                        Dir.mkdir(dir)
                        job = fork do
                            exec "cd #{dir} && #{$self_invoke} -w #{id} #{$autoconf_path}"
                        end
                        $workers[job] = dir
                    end
                end
            end

            # wait a while
            sleep 5
        end

        # clean up any workers and directories
        $workers.each_pair do |job, dir|
            Process.wait(job.to_i)
            FileUtils.rm_rf(dir)
        end
        #begin
            #Dir.glob("*").each do |fn|
                #if fn =~ Regexp.new("^#{$binary_name}_\\d+_worker\\d+$") then
                    #FileUtils.rm_rf(fn)
                #end
            #end
        #rescue
            #puts "Error clearing old worker directories"
        #end

        # move any unfinished configs back to the workqueue
        if get_inproc_length > 0 then
            puts "Unfinished jobs; restarting workers ..."
            move_all_inproc_to_workqueue
        end
    end
end
# }}}

# {{{ finalize_autoconf
def finalize_autoconf

    if File.exist?($final_path) then
        # another process is already finalizing
        puts "Finalization already underway."
        return
    else
        Dir.mkdir($final_path)
    end

    # queue status output
    puts "Candidate queue exhausted.  [Max queue length: ~#{$max_queue_length} item(s)]"

    # generate final config file
    print "Generating final configuration ... "
    $stdout.flush
    build_final_config
    build_debug_config
    FileUtils.cp($final_config_name, $final_path)
    puts "done."

    # try the final config (and keep results)
    Dir.chdir($final_path)
    run_config_file($final_config_name, true, "final")
    Dir.chdir($autoconf_path)

    # start generating final report
    report = build_best_report(true)

    # clean all config and temporary files
    $all_cfgs.each_pair do |key, cfg|
        File.delete(cfg.filename) if File.exists?(cfg.filename)
    end
    File.delete($workqueue_fn)
    File.delete($inproc_fn)

    # finalize report
    elapsed = Time.now.to_f - $start_time.to_f
    report << "Total configs generated:  #{"%6d" % $all_cfgs.size}"
    report << "Total configs tested:     #{"%6d" % get_tested_length}"
    report << "  Total passed:           #{"%6d" % get_regexps_length("passed")}"
    report << "  Total failed:           #{"%6d" % get_regexps_length("failed")}"
    report << "  Total aborted:          #{"%6d" % get_regexps_length("aborted")}"
    report << "Done.  [Total elapsed walltime: #{format_time(elapsed)}]"
    report << ""
    add_to_mainlog(report.join("\n"))
    puts report.join("\n")

    # wtf = wall time file
    # what did *you* think it meant?!?!?
    #
    wtf = File.new($walltime_fn,"w")
    wtf.puts elapsed.to_s
    wtf.close

end
# }}}

# {{{ configuration test helpers

def build_best_report(copy_files=false)
    # find best individual configs
    mainlog = load_mainlog
    cur_cfg = ""
    inst_item = ["",0.0]
    exec_item = ["",0.0]
    inst_hash = Array.new
    exec_hash = Array.new
    mainlog.each do |line|
        if line =~ /Finished (.*):/ then
            cur_cfg = $1
            inst_item = ["",0.0]
            exec_item = ["",0.0]
            has_exec = false
        end
        if line =~ /instrumented .* \[([\d.]*)%\] single/ then
            inst_item = [cur_cfg, inst_item[1]+$1.to_f]
        end
        if line =~ /executed .* \[([\d.]*)%\] single/ then
            exec_item = [cur_cfg, exec_item[1]+$1.to_f]
        end
        if (not cur_cfg == "final") and line.include?($STATUS_PASSED) then
            inst_hash << inst_item
            exec_hash << exec_item
        end
    end
    inst_hash = inst_hash.sort_by { |cfg,pct| -pct }
    exec_hash = exec_hash.sort_by { |cfg,pct| -pct }
    report = Array.new
    report << " "
    report << " Top %-14s%15s  %s"%["instrumented:","CONFIG","% REPLACED"]
    10.times do
        entry = inst_hash.shift
        if !entry.nil? then
            cfg = $all_cfgs[entry[0]]
            if !cfg.nil? then
                FileUtils.cp(cfg.filename, $best_path) if copy_files
                report << "    %30s  %4.1f"%[cfg.tag,entry[1]]
            else
                report << "    %30s  %4.1f"%[entry[0],entry[1]]
            end
        end
    end
    report << " "
    report << " Top %-14s%15s  %s"%["executed:","CONFIG","% REPLACED"]
    10.times do
        entry = exec_hash.shift
        if !entry.nil? then
            cfg = $all_cfgs[entry[0]]
            if !cfg.nil? then
                FileUtils.cp(cfg.filename, $best_path) if copy_files
                report << "    %30s  %4.1f"%[cfg.tag,entry[1]]
            else
                report << "    %30s  %4.1f"%[entry[0],entry[1]]
            end
        end
    end
    report << " "
    return report
end

def build_final_config
    final_config_regexps = load_regexps("passed")
    final_config = File.open($final_config_name, "w")
    IO.foreach($orig_config_name) do |line|
        line_found = false
        final_config_regexps.each do |reg|
            if !line_found && line =~ reg then
                final_config.puts "^#{$stat_preferred}#{line[2,line.size-1]}"
                line_found = true
            end
        end
        if !line_found then
            if line =~ /^\^c/ then
                final_config.puts "^#{$stat_alternate}#{line[2,line.size-1]}"
            else
                final_config.puts line
            end
        end
    end
    final_config.close
end

def build_debug_config
    passed_regexps = load_regexps("passed")
    failed_regexps = load_regexps("failed")
    aborted_regexps = load_regexps("aborted")
    debug_config = File.open($debug_config_name, "w")
    IO.foreach($orig_config_name) do |line|
        line_found = false
        passed_regexps.each do |reg|
            if !line_found && line =~ reg then
                debug_config.puts "^#{$stat_preferred}#{line[2,line.size-1]}"
                line_found = true
            end
        end
        failed_regexps.each do |reg|
            if !line_found && line =~ reg then
                debug_config.puts "^#{$stat_alternate}#{line[2,line.size-1]}"
                line_found = true
            end
        end
        aborted_regexps.each do |reg|
            if !line_found && line =~ reg then
                debug_config.puts "^#{$stat_ignored}#{line[2,line.size-1]}"
                line_found = true
            end
        end
        if !line_found then
            debug_config.puts "^#{$stat_blank}#{line[2,line.size-1]}"
        end
    end
    debug_config.close
end

# build and run a configuration (takes a configuration object)
def run_config (cfg)

    # write configuration file
    cfg_path = $autoconf_path + cfg.filename
    f = File.new(cfg_path, "w")
    IO.foreach($orig_config_name) do |line|
        if line =~ cfg.regexp then
            f.puts "^#{$stat_preferred}#{line[2,line.size-1]}"
        elsif line =~ /^\^c/ then
            f.puts "^#{$stat_alternate}#{line[2,line.size-1]}"
        else
            f.puts line
        end
    end
    f.close

    # pass off to filename version
    status = run_config_file(cfg_path, false, cfg.key)

    # add regexp to appropriate file
    if status == $STATUS_PASSED then
        add_regexp("passed", cfg.regexp)
    elsif status == $STATUS_FAILED then
        add_regexp("failed", cfg.regexp)
    elsif status == $STATUS_ERROR then
        add_regexp("aborted", cfg.regexp)
    end

    return status
end

# build and run a configuration (takes a .cfg filename)
def run_config_file (fn, keep, key)

    # status updates
    #basename = File.basename(fn)
    #if basename =~ /^#{$binary_name}(.*)/ then
        #basename = $1
    #end
    #puts "  Testing #{basename} ..."
    $status_buffer = "    Finished #{key}:\n"

    # build rewritten mutatee
    cmd = "fpinst -i #{$fortran_mode ? "-N" : ""}"
    cmd += " -c #{fn}"
    cmd += " #{$binary_path}"
    #add_to_mainlog("    Building mutatee for #{basename}: #{cmd}")
    io_in, io_out, io_err = Open3.popen3(cmd)
    io_err.each_line do |line| end
    io_out.each_line do |line|
        if line =~ /Inplace: (.*)$/ then
            $status_buffer += "        #{$1}\n"
        end
    end

    # execute rewritten mutatee and check for success
    status = $STATUS_ERROR
    runtime = 0
    error = 0.0
    cmd = "#{$autoconf_path}#{$craft_driver} #{Dir.getwd}/mutant"
    #add_to_mainlog("    Testing mutatee for #{basename}: #{cmd}")
    io_in, io_out, io_err = Open3.popen3(cmd)
    io_err.each_line do |line| end
    io_out.each_line do |line|
        if line =~ /status:\s*(pass|fail)/i then
            tmp = $1
            if tmp =~ /pass/i then
                status = $STATUS_PASSED
            elsif tmp =~ /fail/i then
                status = $STATUS_FAILED
            end
        elsif line =~ /error:\s*(.+)/i then
            error = $1.to_f
        elsif line =~ /time:\s*(.+)/i then
            runtime = $1.to_i
        end
    end

    # scan log file(s) for info
    Dir.glob("*.log").each do |lfn|
        if lfn != "fpinst.log" then
            IO.foreach(lfn) do |line|
                if line =~ /Inplace: (.*)$/ then
                    $status_buffer += "        #{$1.gsub(/<.*>/, "")}\n"
                end
            end
        end
    end

    # print output
    $status_buffer += "        #{status}"
    $status_buffer += "  [Walltime: #{format_time(runtime.to_f)}"
    $status_buffer += " %.1fX"%[runtime / $baseline_runtime.to_f]
    $status_buffer += " Error: %g]"%[error]
    puts $status_buffer
    add_to_mainlog($status_buffer)
    $status_buffer = ""

    # clean out mutant, logs, and rewritten library files
    if !keep then
        begin
            Dir.glob("*").each do |lfn|
                if lfn =~ /mutant/ || lfn =~ /\.log/ || lfn =~ /lib(c|m)\.so\.6/ then
                    File.delete(lfn)
                end
            end
        rescue
            puts "Error clearing old files"
        end
    end

    # copy config to appropriate folder
    if status == $STATUS_PASSED then
        FileUtils.cp(fn, $passed_path)
    elsif status == $STATUS_FAILED then
        FileUtils.cp(fn, $failed_path)
    elsif status == $STATUS_ERROR then
        FileUtils.cp(fn, $aborted_path)
    end

    # rebuild "best-so-far" config
    build_final_config
    build_debug_config

    return status
end

# }}}

# {{{ file helpers

def save_all_configs
    f = File.new($settings_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.puts $start_time.to_i
    f.puts $binary_name
    f.puts $binary_path
    f.puts $stat_preferred
    f.puts $stat_alternate
    f.puts $baseline_runtime
    f.puts($fortran_mode ? "fortran" : "other")
    f.puts $initial_cfg_fn
    f.close
    f = File.new($allconfigs_fn, File::RDWR)
    f.flock File::LOCK_EX
    puts "Saving all configurations to disk."
    YAML.dump($all_cfgs, f)
    puts "Done saving configurations."
    f.close
end
def load_all_configs(full=true)
    # could probably be read-only
    f = File.new($settings_fn, File::RDWR)
    f.flock File::LOCK_EX
    $start_time = Time.at(f.gets.to_i)
    $binary_name = f.gets.chomp
    $binary_path = f.gets.chomp
    $stat_preferred = f.gets.chomp
    $stat_alternate = f.gets.chomp
    $baseline_runtime = f.gets.chomp.to_i
    lang = f.gets.chomp
    if lang == "fortran" then
        $fortran_mode = true
    else
        $fortran_mode = false
    end
    $initial_cfg_fn = f.gets.chomp
    f.close
    # could probably be read-only
    if full then
        f = File.new($allconfigs_fn, File::RDWR)
        f.flock File::LOCK_EX
        $all_cfgs = YAML.load(f)
        f.close
    end
end


def add_to_workqueue(item)
    f = File.new($workqueue_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(item)
    f.close
end
def get_next_workqueue_item
    item = ""
    workqueue = Array.new
    f = File.new($workqueue_fn, File::RDWR)
    f.flock File::LOCK_EX
    workqueue = f.readlines
    item = workqueue.shift
    f.pos = 0
    f.print workqueue
    f.truncate(f.pos)
    f.close
    if !item.nil? then
        item.chomp!
    end
    return item
end
def get_workqueue_length
    # could probably be read-only
    begin
        f = File.new($workqueue_fn, File::RDWR)
        f.flock File::LOCK_EX
        workqueue = f.readlines
        f.close
    rescue
        return 0
    end
    return workqueue.size
end


def add_to_inproc(item)
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(item)
    f.close
end
def remove_from_inproc(item)
    inproc = Array.new
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    inproc = f.readlines
    inproc.each do |ipitem|
        if ipitem.chomp == item then
            inproc.delete(ipitem)
        end
    end
    f.pos = 0
    f.print inproc
    f.truncate(f.pos)
    f.close
end
def get_inproc_length
    # could probably be read-only
    begin
        f = File.new($inproc_fn, File::RDWR)
        f.flock File::LOCK_EX
        inproc = f.readlines
        f.close
    rescue
        return 0
    end
    return inproc.size
end
def move_all_inproc_to_workqueue
    inproc = Array.new
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    inproc = f.readlines
    f.close
    inproc.each do |item|
        remove_from_inproc(item.chomp)
        add_to_workqueue(item.chomp)
    end
end


def add_to_tested(item)
    f = File.new($tested_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(item)
    f.close
end
def get_tested_length
    # could probably be read-only
    f = File.new($tested_fn, File::RDWR)
    f.flock File::LOCK_EX
    tested = f.readlines
    f.close
    return tested.size
end


def add_regexp(tag, reg)
    f = File.new("#{$regexps_fn}-#{tag}", File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(reg.to_s)
    f.close
end
def load_regexps(tag)
    # could probably be read-only
    f = File.new("#{$regexps_fn}-#{tag}",  File::RDWR)
    f.flock File::LOCK_EX
    lines = f.readlines
    f.close
    regexps = Array.new
    lines.each do |line|
        regexps << Regexp.new(line.chomp)
    end
    return regexps
end
def get_regexps_length(tag)
    # could probably be read-only
    f = File.new("#{$regexps_fn}-#{tag}",  File::RDWR)
    f.flock File::LOCK_EX
    lines = f.readlines
    f.close
    return lines.size
end


def add_to_mainlog(reg)
    f = File.new($mainlog_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(reg.to_s)
    f.close
end
def load_mainlog
    # could probably be read-only
    f = File.new($mainlog_fn,  File::RDWR)
    f.flock File::LOCK_EX
    lines = f.readlines
    f.close
    return lines
end

# }}}

# {{{ misc helpers
def format_time (elapsed)
    mins, secs = elapsed.divmod 60.0
    hrs, mins = mins.divmod 60.0
    #return "%d:%02d:%05.2f"%[hrs.to_i, mins.to_i, secs]
    return "%d:%02d:%02d"%[hrs.to_i, mins.to_i, secs.to_i]
end
# }}}

main

