#!/usr/bin/ruby
#
# fpautoconf
#
# Generate floating-point precision configurations for a target binary, and test
# them. Assemble a final recommended configuration.
#
# Mike Lam, UMD
# February 2012
#

# needed for opening stderr as well as stdin/stdout
# when spawning new system processes
require 'open3.rb'

# needed for object serialization
require 'yaml.rb'

# needed for easier directory removal
require 'fileutils.rb'

# {{{ main method
def main
    srand

    # global variables
    $stat_preferred = "s"       # preferred replacement status
    $stat_alternate = "d"       # replacement status if cannot be preferred
    $fortran_mode = false       # pass "-N" to fpinst
    $data_files = Array.new     # required data files
    $cmdline_options = ""       # mutatee command line options
    $mpi_enabled = false        # use mpirun?
    $mpi_procs = 0              # number of MPI processes
    $max_queue_length = 0       # track largest queue size (approximate)
    $is_worker = false          # is this the parent process or a worker?
    $workers = Hash.new         # worker proc info (pid => dirname)
    $status_buffer = ""         # buffer for output (keeps multiprocess output clean)
    $all_cfgs = Hash.new        # collection of all configs (key => cfg)
    $self_invoke = File.basename($0)

    # check command-line options
    if ARGV.size == 0 or ARGV.include?("-h") then
        puts "Usage:  #{$self_invoke} [options] <binary>        (parent process)"
        puts "          or"
        puts "        #{$self_invoke} -r                       (resume parent process)"
        puts "          or"
        puts "        #{$self_invoke} -w <dir>                 (worker process)"
        puts "Valid options:"
        puts "   -c \"opts\"    pass command-line options to mutatee"
        puts "   -d             debug mode (ignore->double)"
        puts "   -D <file>      copy in a data file"
        puts "   -j <np>        spawn <np> worker threads"
        puts "   -np <np>       use MPI with <np> processes"
        puts "   -N             enable Fortran mode"
        exit
    end

    # parse command-line options
    num_workers = 1
    begin
        opt = ARGV.shift
        if opt == "-r" then
        elsif opt == "-w" then
            # worker process
            $is_worker = true
            $autoconf_path = ARGV.shift
        elsif opt == "-np" then
            # enable MPI
            $mpi_enabled = true
            $mpi_procs = ARGV.shift.to_i
        elsif opt == "-j" then
            # parallel: "-j 4" variant
            num_workers = ARGV.shift.to_i
        elsif opt =~ /^-j/ then
            # parallel: "-j4" variant
            num_workers = opt[2,opt.length-2].to_i
        elsif opt == "-d" then
            # debug mode
            $stat_preferred = "d"
            $stat_alternate = "i"
        elsif opt == "-D" then
            # data file
            $data_files << ARGV.shift
        elsif opt == "-c" then
            # command-line option
            $cmdline_options = ARGV.shift
        elsif opt == '-N' then
            # fortran mode
            $fortran_mode = true
        end
    end while ARGV.size > 0

    # set up environment and filenames
    if !$is_worker then
        $autoconf_path = Dir.getwd + "/"
    end
    $settings_fn = "#{$autoconf_path}fpautoconf.settings"
    $allconfigs_fn = "#{$autoconf_path}fpautoconf.allconfigs"
    $workqueue_fn = "#{$autoconf_path}fpautoconf.workqueue"
    $inproc_fn = "#{$autoconf_path}fpautoconf.inproc"
    $finalregexps_fn = "#{$autoconf_path}fpautoconf.finalregexps"
    $mainlog_fn = "#{$autoconf_path}fpautoconf.mainlog"
    $orig_config_name = "#{$autoconf_path}fpautoconf_orig.cfg"
    $final_config_name = "#{$autoconf_path}fpautoconf_final.cfg"
    $final_path = "#{$autoconf_path}final/"

    if $is_worker then

        # worker process
        load_all_configs
        run_main_autoconf_loop
        puts "Worker finished.  [Empty queue]"

    else

        $binary_name = File.basename(opt)
        $binary_path = File.expand_path(opt)
        puts "FPAutoConf"
        puts "Autoconfiguring #{$binary_name} ..."
        puts "Working dir: #{$autoconf_path}"

        if !File.exist?($workqueue_fn) then
            # first invocation of this analysis; initialize everything
            initialize_autoconf
        else
            puts "Resuming previous analysis ..."
            load_all_configs
            #move_all_inproc_to_workqueue
        end

        # spawn workers
        num_workers.times do |i|
            puts "Spawning worker #{i} ..."
            worker_dir = "#{$autoconf_path + $binary_name}_#{Process.pid}_worker#{i}"
            if File.exist?(worker_dir) then
                FileUtils.rm_rf(worker_dir)
            end
            Dir.mkdir(worker_dir)
            job = fork do
                exec "cd #{worker_dir} && #{$self_invoke} -w #{$autoconf_path} &>output.txt"
            end
            $workers[job] = worker_dir
        end

        # main loop
        run_main_supervisor_loop

        # parent finalization
        finalize_autoconf

    end
end
# }}}

# {{{ SingleReplacementConfig
# stores single config info (mainly for serialization)
class SingleReplacementConfig
    attr_accessor :key              # unique config identifier
    attr_accessor :filename         # .cfg filename
    attr_accessor :type             # func, bblk, insn
    attr_accessor :regexp           # config pattern for creating final config
    attr_accessor :icount           # number of fp instructions replaced
    attr_accessor :children         # proper subset configs
    def initialize(id, type)
        @key = "#{type}_#{id}"
        @filename = "#{$binary_name}_#{key}.cfg"
        @type = type
        if @type == "func" then
            @regexp = Regexp.new("FUNC.*\"#{id}\"")
        elsif @type == "bblk" then
            @regexp = Regexp.new("BBLK #\\d+: 0x#{id}")
        elsif @type == "insn" then
            @regexp = Regexp.new("INSN #\\d+: 0x#{id}")
        else
            @regexp = //
        end
        if @type == "insn" then
            @icount = 1
        else
            @icount = 0
        end
        @children = Array.new
    end
end
# }}}

# {{{ initialize_autoconf
def initialize_autoconf

    # parent initialization
    $start_time = Time.now

    # delete all existing .cfg files (and old mutant files)
    Dir.foreach($autoconf_path) do |fn|
        if fn =~ /\.cfg/ || fn =~ /lib(c|m)\.so\.6/ || fn =~ /\.log/ || fn =~ /mutant/ then
            File.delete(fn)
        elsif fn =~ /worker\d+/ then
            FileUtils.rm_rf(fn)
        end
    end

    # create search config files
    File.new($settings_fn, "w").close
    File.new($allconfigs_fn, "w").close
    File.new($workqueue_fn, "w").close
    File.new($inproc_fn, "w").close
    File.new($finalregexps_fn, "w").close
    File.new($mainlog_fn, "w").close

    # copy in data files
    tmp = Array.new
    $data_files.each do |fname|
        FileUtils.cp(fname, $autoconf_path)
        tmp << File.basename(fname)
    end
    $data_files = Array.new
    tmp.each do |fname|
        $data_files << tmp
    end

    # initial performance run
    print "Performing baseline performance test ... "
    $stdout.flush
    start = Time.now
    if $mpi_enabled then
        cmd = "mpirun -np #{$mpi_procs} #{$binary_path} #{$cmdline_options}"
    else
        cmd = "#{$binary_path} #{$cmdline_options}"
    end
    Open3.popen3(cmd) do |io_in, io_out, io_err, io_wait|
        io_out.each_line do |line|
        end
    end
    $baseline_runtime = Time.now.to_f - start.to_f
    puts " [Base walltime: #{format_time($baseline_runtime)}]"

    # generate initial configuration by calling fpconf
    # and initialize global data structures
    print "Generating initial configuration ... "
    $stdout.flush
    orig_cfg = File.open($orig_config_name, "w")
    func = nil
    bblk = nil
    IO.popen("fpconf #{$binary_path}") do |io|
        io.each_line do |line|
            orig_cfg.puts line
            if line =~ /FUNC.*\"(.+)\"/ then
                func = SingleReplacementConfig.new($1, "func")
                $all_cfgs[func.key] = func
            end
            if line =~ /BBLK #\d+: 0x([0-9A-Fa-f]+)/ then
                bblk = SingleReplacementConfig.new($1, "bblk")
                $all_cfgs[bblk.key] = bblk
                func.children << bblk.key if func != nil
            end
            if line =~ /INSN #\d+: 0x([0-9A-Fa-f]+)/ then
                insn = SingleReplacementConfig.new($1, "insn")
                $all_cfgs[insn.key] = insn
                bblk.children << insn.key if bblk != nil
                bblk.icount += 1
                func.icount += 1
            end
        end
    end
    orig_cfg.close
    puts "done."

    # throw away empty configs
    to_delete = Array.new
    $all_cfgs.each_pair do |key, cfg|
        to_delete << key if cfg.icount == 0
    end
    to_delete.each do |key|
        $all_cfgs.delete(key)
    end

    # save project config to file (for workers to load)
    save_all_configs

    # initialize work queue
    # start by trying all functions
    count = 0
    $all_cfgs.each_pair do |key, cfg|
        # FOR TESTING: limit to five functions
        #if cfg.type == "func" && cfg.icount > 0 && count < 5
        if cfg.type == "func" && cfg.icount > 0 then
            add_to_workqueue(cfg.key)
            count += 1
        end
    end
    $max_queue_length = get_workqueue_length

end
# }}}

# {{{ run_main_autoconf_loop
def run_main_autoconf_loop
    key = get_next_workqueue_item

    # main search loop
    while !key.nil? && key != "" do

        add_to_inproc(key)

        # grab configuration object
        cfg = $all_cfgs[key]

        # queue status output
        queue_length = get_workqueue_length
        $status_buffer += "[Queue length: #{"%3d" % (queue_length+1)}]  "
        $max_queue_length = queue_length if queue_length > $max_queue_length

        if run_config(cfg) then

            # this config passed; add it to the final
            add_final_regexp(cfg.regexp)

        else

            # add any children we need to test
            if (cfg.type == "func" && cfg.icount >= 1) ||
               (cfg.type == "bblk" && cfg.icount >= 2) then
                cfg.children.each do |ckey|
                    child = $all_cfgs[ckey]
                    if child != nil then
                        add_to_workqueue(ckey)
                    end
                end
            end

        end

        remove_from_inproc(key)
        key = get_next_workqueue_item
    end

end
# }}}

# {{{ run_main_supervisor_loop
def run_main_supervisor_loop
    while get_workqueue_length > 0 or get_inproc_length > 0 do
        while get_workqueue_length > 0 do

            # restart any dead worker processes
            if !$is_worker && get_workqueue_length > 0 then
                $workers.each_pair do |job, dir|
                    cmd = "ps -o s= p #{job.to_i}"
                    stat = `#{cmd}`
                    stat.chomp!
                    if stat != "S" then
                        $workers.delete(job)
                        id = File.basename(dir)
                        if id =~ /worker(\d+)/ then
                            id = $1
                        else
                            id = id[$binary_name.length+1,id.length-$binary_name.length-1]
                        end
                        puts "Respawning worker #{id} ..."
                        FileUtils.rm_rf(dir)
                        Dir.mkdir(dir)
                        job = fork do
                            exec "cd #{dir} && #{$self_invoke} -w #{$autoconf_path} &>output.txt"
                        end
                        $workers[job] = dir
                    end
                end
            end

            # wait a while
            sleep 5
        end

        # clean up any workers and directories
        $workers.each_pair do |job, dir|
            Process.wait(job.to_i)
            FileUtils.rm_rf(dir)
        end
        Dir.foreach(".") do |fn|
            if fn =~ Regexp.new("^#{$binary_name}_\\d+_worker\\d+$") then
                FileUtils.rm_rf(fn)
            end
        end

        # move any unfinished configs back to the workqueue
        if get_inproc_length > 0 then
            puts "Unfinished jobs; restarting workers ..."
            move_all_inproc_to_workqueue
        end
    end
end
# }}}

# {{{ finalize_autoconf
def finalize_autoconf

    if File.exist?($final_path) then
        # another process is already finalizing
        puts "Finalization already underway."
        return
    else
        Dir.mkdir($final_path)
    end

    # queue status output
    puts "Candidate queue exhausted.  [Max queue length: ~#{$max_queue_length} item(s)]"

    # generate final config file
    final_config_regexps = load_final_regexps
    print "Generating final configuration ... "
    $stdout.flush
    final_config = File.open($final_config_name, "w")
    IO.foreach($orig_config_name) do |line|
        line_found = false
        final_config_regexps.each do |reg|
            if !line_found && line =~ reg then
                final_config.puts "^#{$stat_preferred}#{line[2,line.size-1]}"
                line_found = true
            end
        end
        if !line_found then
            if line =~ /^\^s/ then
                final_config.puts "^#{$stat_alternate}#{line[2,line.size-1]}"
            else
                final_config.puts line
            end
        end
    end
    final_config.close
    puts "done."

    # find best individual configs
    kept_configs = Array.new
    mainlog = load_mainlog
    cur_cfg = ""
    inst_item = ["",0.0]
    exec_item = ["",0.0]
    inst_hash = Array.new
    exec_hash = Array.new
    mainlog.each do |line|
        if line =~ /Finished (.*\.cfg):/ then
            cur_cfg = $1
            inst_item = ["",0.0]
            exec_item = ["",0.0]
            has_exec = false
        end
        if line =~ /instrumented .* \[([\d.]*)%\] single/ then
            inst_item = [cur_cfg, inst_item[1]+$1.to_f]
        end
        if line =~ /executed .* \[([\d.]*)%\] single/ then
            puts line
            exec_item = [cur_cfg, exec_item[1]+$1.to_f]
        end
        if line =~ /Success!/ then
            if $mpi_enabled then
                inst_item[1] /= $mpi_procs.to_f
                exec_item[1] /= $mpi_procs.to_f
            end
            inst_hash << inst_item
            exec_hash << exec_item
        end
    end
    inst_hash = inst_hash.sort_by { |cfg,pct| -pct }
    exec_hash = exec_hash.sort_by { |cfg,pct| -pct }
    report = Array.new
    report << " "
    report << "Top %-15s%15s  %s"%["instrumented:","CONFIG","% REPLACED"]
    10.times do
        entry = inst_hash.shift
        if !entry.nil? then
            report << "    %30s  %4.1f"%[entry[0],entry[1]]
            kept_configs << "#{$binary_name}#{entry[0]}"
        end
    end
    report << " "
    report << "Top %-15s%15s  %s"%["executed:","CONFIG","% REPLACED"]
    10.times do
        entry = exec_hash.shift
        if !entry.nil? then
            report << "    %30s  %4.1f"%[entry[0],entry[1]]
            kept_configs << "#{$binary_name}#{entry[0]}"
        end
    end
    report << " "
    add_to_mainlog(report.join("\n"))

    # try the final config (and keep results)
    Dir.chdir($final_path)
    run_config_file($final_config_name, true)
    Dir.chdir($autoconf_path)

    # clean all config and temporary files
    $all_cfgs.each_pair do |key, cfg|
        File.delete(cfg.filename) if File.exists?(cfg.filename) and not kept_configs.include?(cfg.filename)
    end
    #File.delete($settings_fn)
    #File.delete($allconfigs_fn)
    File.delete($workqueue_fn)
    File.delete($inproc_fn)
    #File.delete($finalregexps_fn)

    elapsed = Time.now.to_f - $start_time.to_f
    puts "Done.  [Elapsed walltime: #{format_time(elapsed)}]"

end
# }}}

# {{{ configuration test helpers

# build and run a configuration (takes a configuration object)
def run_config (cfg)

    # write configuration file
    cfg_path = $autoconf_path + cfg.filename
    f = File.new(cfg_path, "w")
    IO.foreach($orig_config_name) do |line|
        if line =~ cfg.regexp then
            f.puts "^#{$stat_preferred}#{line[2,line.size-1]}"
        elsif line =~ /^\^s/ then
            f.puts "^#{$stat_alternate}#{line[2,line.size-1]}"
        else
            f.puts line
        end
    end
    f.close

    # pass off to filename version
    return run_config_file(cfg_path, false)
end

# build and run a configuration (takes a .cfg filename)
def run_config_file (fn, keep)

    # status updates
    basename = File.basename(fn)
    basename = basename[$binary_name.length, basename.length-$binary_name.length]
    puts "Testing #{basename} ..."
    $status_buffer = "    Finished #{basename}:\n"

    # TODO: FOR TESTING; remove this!
    #success = true
    #if rand(6) == 0 then
        #success = true
    #else
        #success = false
    #end
    #if success then
        #$status_buffer += "success!"
    #else
        #$status_buffer += "FAILED!"
    #end
    #puts $status_buffer
    #$status_buffer = ""
    #return success

    # build rewritten mutatee
    cmd = "fpinst -i #{$fortran_mode ? "-N" : ""}"
    cmd += " -c #{fn}"
    cmd += " #{$binary_path}"
    add_to_mainlog("    Building mutatee for #{basename}: #{cmd}")
    Open3.popen3(cmd) do |io_in, io_out, io_err, io_wait|
        io_out.each_line do |line|
            if line =~ /Inplace: (.*)$/ then
                $status_buffer += "        #{$1}\n"
            end
        end
    end

    # copy in any data files
    $data_files.each do |fname|
        FileUtils.cp("#{$autoconf_path}#{fname}", Dir.getwd)
    end

    # execute rewritten mutatee and check for success
    success = false
    start = Time.now
    if $mpi_enabled then
        cmd = "mpirun -np #{$mpi_procs} mutant #{$cmdline_options}"
    else
        cmd = "./mutant #{$cmdline_options}"
    end
    add_to_mainlog("    Testing mutatee for #{basename}: #{cmd}")
    Open3.popen3(cmd) do |io_in, io_out, io_err, io_wait|
        io_out.each_line do |line|
            if line =~ /Inplace: (.*)$/ then
                $status_buffer += "        #{$1}\n"
            end
            if !success && line =~ /[^N]SUCCESS/ then
                success = true
            end
        end
    end
    elapsed = Time.now.to_f - start.to_f
    if success then
        $status_buffer += "        Success!"
    else
        $status_buffer += "        FAILED!"
    end
    $status_buffer += "  [Walltime: #{format_time(elapsed)}"
    $status_buffer += " %.1fX]"%[elapsed / $baseline_runtime]
    #puts $status_buffer
    add_to_mainlog($status_buffer)
    $status_buffer = ""

    # clean out mutant, logs, and rewritten library files
    if !keep then
        Dir.foreach(".") do |fn|
            if fn =~ /mutant/ || fn =~ /\.log/ || fn =~ /lib(c|m)\.so\.6/ then
                File.delete(fn)
            end
        end
    end

    return success
end

# }}}

# {{{ file helpers

def save_all_configs
    f = File.new($settings_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.puts $start_time.to_i
    f.puts $binary_name
    f.puts $binary_path
    f.puts $stat_preferred
    f.puts $stat_alternate
    f.puts $baseline_runtime
    f.puts $mpi_procs
    f.puts $cmdline_options
    f.puts($fortran_mode ? "fortran" : "other")
    f.puts($data_files.size)
    $data_files.each do |fname|
        f.puts(fname)
    end
    f.close
    f = File.new($allconfigs_fn, File::RDWR)
    f.flock File::LOCK_EX
    YAML.dump($all_cfgs, f)
    f.close
end
def load_all_configs
    # could probably be read-only
    f = File.new($settings_fn, File::RDWR)
    f.flock File::LOCK_EX
    $start_time = Time.at(f.gets.to_i)
    $binary_name = f.gets.chomp
    $binary_path = f.gets.chomp
    $stat_preferred = f.gets.chomp
    $stat_alternate = f.gets.chomp
    $baseline_runtime = f.gets.chomp.to_f
    $mpi_procs = f.gets.chomp.to_i
    $cmdline_options = f.gets.chomp
    if $mpi_procs > 0 then
        $mpi_enabled = true
    else
        $mpi_enabled = false
    end
    lang = f.gets.chomp
    if lang == "fortran" then
        $fortran_mode = true
    else
        $fortran_mode = false
    end
    $data_files = Array.new
    num = f.gets.chomp.to_i
    num.times do |i|
        $data_files << f.gets.chomp
    end
    f.close
    # could probably be read-only
    f = File.new($allconfigs_fn, File::RDWR)
    f.flock File::LOCK_EX
    $all_cfgs = YAML.load(f)
    f.close
end


def add_to_workqueue(item)
    f = File.new($workqueue_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(item)
    f.close
end
def get_next_workqueue_item
    item = ""
    workqueue = Array.new
    f = File.new($workqueue_fn, File::RDWR)
    f.flock File::LOCK_EX
    workqueue = f.readlines
    item = workqueue.shift
    f.pos = 0
    f.print workqueue
    f.truncate(f.pos)
    f.close
    if !item.nil? then
        item.chomp!
    end
    return item
end
def get_workqueue_length
    # could probably be read-only
    f = File.new($workqueue_fn, File::RDWR)
    f.flock File::LOCK_EX
    workqueue = f.readlines
    f.close
    return workqueue.size
end


def add_to_inproc(item)
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(item)
    f.close
end
def remove_from_inproc(item)
    inproc = Array.new
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    inproc = f.readlines
    inproc.each do |ipitem|
        if ipitem.chomp == item then
            inproc.delete(ipitem)
        end
    end
    f.pos = 0
    f.print inproc
    f.truncate(f.pos)
    f.close
end
def get_inproc_length
    # could probably be read-only
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    inproc = f.readlines
    f.close
    return inproc.size
end
def move_all_inproc_to_workqueue
    inproc = Array.new
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    inproc = f.readlines
    f.close
    inproc.each do |item|
        remove_from_inproc(item.chomp)
        add_to_workqueue(item.chomp)
    end
end


def add_final_regexp(reg)
    f = File.new($finalregexps_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(reg.to_s)
    f.close
end
def load_final_regexps
    # could probably be read-only
    f = File.new($finalregexps_fn,  File::RDWR)
    f.flock File::LOCK_EX
    lines = f.readlines
    f.close
    final_config_regexps = Array.new
    lines.each do |line|
        final_config_regexps << Regexp.new(line.chomp)
    end
    return final_config_regexps
end


def add_to_mainlog(reg)
    f = File.new($mainlog_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(reg.to_s)
    f.close
end
def load_mainlog
    # could probably be read-only
    f = File.new($mainlog_fn,  File::RDWR)
    f.flock File::LOCK_EX
    lines = f.readlines
    f.close
    return lines
end

# }}}

# {{{ misc helpers
def format_time (elapsed)
    mins, secs = elapsed.divmod 60.0
    hrs, mins = mins.divmod 60.0
    return "%d:%02d:%05.2f"%[hrs.to_i, mins.to_i, secs]
end
# }}}

main

