#!/usr/bin/ruby
#
# fpautoconf
#
# Generate floating-point precision configurations for a target binary, and test
# them. Assemble a final recommended configuration.
#
# Mike Lam, UMD
# February 2012
#

# needed for opening stderr as well as stdin/stdout
# when spawning new system processes
require 'open3.rb'

# needed for object serialization
require 'yaml.rb'

# needed for easier directory removal
require 'fileutils.rb'

# {{{ main method
def main
    srand

    # global variables
    $craft_driver = "craft_driver"    # standard driver program name
    $stat_preferred = "s"       # preferred replacement status
    $stat_alternate = "d"       # replacement status if cannot be preferred
    $fortran_mode = false       # pass "-N" to fpinst
    $initial_cfg_fn = ""        # initial config filename (may be blank)
    $max_queue_length = 0       # track largest queue size (approximate)
    $is_worker = false          # is this the parent process or a worker?
    $workers = Hash.new         # worker proc info (pid => dirname)
    $status_buffer = ""         # buffer for output (keeps multiprocess output clean)
    $all_cfgs = Hash.new        # collection of all configs (key => cfg)
    $self_invoke = File.basename($0)

    # check command-line options
    if ARGV.size == 0 or ARGV.include?("-h") then
        puts "Usage:  #{$self_invoke} [options] <binary>        (parent process)"
        puts "          or"
        puts "        #{$self_invoke} -r                       (resume parent process)"
        puts "          or"
        puts "        #{$self_invoke} -w <dir>                 (worker process)"
        puts "          or"
        puts "        #{$self_invoke} clean                    (reset search)"
        puts "Valid options:"
        puts "   -c <file>      use <file> as initial base configuration"
        puts "   -d             debug mode (ignore->double instead of double->single)"
        puts "   -j <np>        spawn <np> worker threads"
        puts "   -N             enable Fortran mode (passes \"-N\" to fpinst)"
        exit
    end

    # cleaning mode
    if ARGV.size == 1 and ARGV[0] == "clean" then
        puts "Cleaning..."
        toDelete = Array.new
        Dir.glob("fpautoconf.*") do |fn| toDelete << fn end
        Dir.glob("*_worker*") do |fn| toDelete << fn end
        Dir.glob("*.cfg") do |fn| toDelete << fn end
        Dir.glob("*.log") do |fn| toDelete << fn end
        toDelete.each do |fn|
            FileUtils.rm_rf(fn)
        end
        puts "Done."
        exit
    end

    # parse command-line options
    num_workers = 1
    begin
        opt = ARGV.shift
        if opt == "-r" then
        elsif opt == "-w" then
            # worker process
            $is_worker = true
            $autoconf_path = ARGV.shift
        elsif opt == "-j" then
            # parallel: "-j 4" variant
            num_workers = ARGV.shift.to_i
        elsif opt =~ /^-j/ then
            # parallel: "-j4" variant
            num_workers = opt[2,opt.length-2].to_i
        elsif opt == "-d" then
            # debug mode
            $stat_preferred = "d"
            $stat_alternate = "i"
        elsif opt == "-c" then
            # initial configuration
            $initial_cfg_fn = ARGV.shift
        elsif opt == '-N' then
            # fortran mode
            $fortran_mode = true
        end
    end while ARGV.size > 0

    # set up environment and filenames
    if !$is_worker then
        $autoconf_path = Dir.getwd + "/"
    end
    $settings_fn = "#{$autoconf_path}fpautoconf.settings"
    $allconfigs_fn = "#{$autoconf_path}fpautoconf.allconfigs"
    $workqueue_fn = "#{$autoconf_path}fpautoconf.workqueue"
    $inproc_fn = "#{$autoconf_path}fpautoconf.inproc"
    $tested_fn = "#{$autoconf_path}fpautoconf.tested"
    $finalregexps_fn = "#{$autoconf_path}fpautoconf.finalregexps"
    $mainlog_fn = "#{$autoconf_path}fpautoconf.mainlog"
    $orig_config_name = "#{$autoconf_path}fpautoconf_orig.cfg"
    $final_config_name = "#{$autoconf_path}fpautoconf_final.cfg"
    $final_path = "#{$autoconf_path}final/"

    # check for driver script
    if !File.exist?("#{$autoconf_path}#{$craft_driver}") then
        puts "No driver program \"craft_driver\" found."
        puts "Aborting."
        exit
    end

    if $is_worker then

        # worker process
        load_all_configs
        run_main_autoconf_loop
        puts "Worker finished.  [Empty queue]"

    else

        $binary_name = File.basename(opt)
        $binary_path = File.expand_path(opt)
        puts "FPAutoConf"
        puts "Autoconfiguring #{$binary_name} ..."
        puts "Working dir: #{$autoconf_path}"

        if !File.exist?($workqueue_fn) then
            # first invocation of this analysis; initialize everything
            initialize_autoconf
        else
            puts "Resuming previous analysis ..."
            load_all_configs
            #move_all_inproc_to_workqueue
        end

        # spawn workers
        num_workers.times do |i|
            puts "Spawning worker #{i} ..."
            worker_dir = "#{$autoconf_path + $binary_name}_#{Process.pid}_worker#{i}"
            if File.exist?(worker_dir) then
                FileUtils.rm_rf(worker_dir)
            end
            Dir.mkdir(worker_dir)
            job = fork do
                exec "cd #{worker_dir} && #{$self_invoke} -w #{$autoconf_path}"
            end
            $workers[job] = worker_dir
        end

        # main loop
        run_main_supervisor_loop

        # parent finalization
        finalize_autoconf

    end
end
# }}}

# {{{ SingleReplacementConfig
# stores single config info (mainly for serialization)
class SingleReplacementConfig
    attr_accessor :key              # unique config identifier
    attr_accessor :filename         # .cfg filename
    attr_accessor :type             # mod, func, bblk, insn
    attr_accessor :regexp           # config pattern for creating final config
    attr_accessor :ccount           # number of candidate fp instructions
    attr_accessor :rcount           # number of restricted (ignore/single/double) structures
    attr_accessor :children         # proper subset configs
    attr_accessor :initial          # value of initial replacement ('c','s','d','i',' ')
    def initialize(id, type, initial)
        @key = "#{type}_#{id}"
        @filename = "#{$binary_name}_#{key}.cfg"
        @type = type
        @children = Array.new
        @initial = initial
        if @type == "mod" then
            @regexp = Regexp.new("MODULE.*\"#{id}\"")
        elsif @type == "func" then
            @regexp = Regexp.new("FUNC.*\"#{id}\"")
        elsif @type == "bblk" then
            @regexp = Regexp.new("BBLK #\\d+: 0x#{id}")
        elsif @type == "insn" then
            @regexp = Regexp.new("INSN #\\d+: 0x#{id}")
        else
            @regexp = //
        end
        if @type == "insn" && @initial == "c" then
            @ccount = 1
        else
            @ccount = 0
        end
        if @initial == "i" || @initial == "s" || @initial == "d" then
            @rcount = 1
        else
            @rcount = 0
        end
    end
end
# }}}

# {{{ initialize_autoconf
def initialize_autoconf

    # parent initialization
    $start_time = Time.now

    # create search config files
    File.new($settings_fn, "w").close
    File.new($allconfigs_fn, "w").close
    File.new($workqueue_fn, "w").close
    File.new($inproc_fn, "w").close
    File.new($tested_fn, "w").close
    File.new($finalregexps_fn, "w").close
    File.new($mainlog_fn, "w").close

    # initial performance run
    print "Performing baseline performance test ... "
    $stdout.flush
    passed = false
    $baseline_error = 0.0
    $baseline_runtime = 0
    cmd = "#{$autoconf_path}#{$craft_driver} #{$binary_path}"
    Open3.popen3(cmd) do |io_in, io_out, io_err, io_wait|
        io_out.each_line do |line|
            if line =~ /status:\s*(pass|fail)/i then
                if $1 =~ /pass/i then
                    passed = true
                end
            end
            if line =~ /error:\s*(.+)/i then
                $baseline_error = $1.to_f
            end
            if line =~ /time:\s*(.+)/i then
                $baseline_runtime = $1.to_i
            end
        end
    end
    if !passed then
        puts "Baseline performance test failed verification!"
        puts "Aborting search."
        exit
    end
    puts " [Base error: #{$baseline_error}  walltime: #{format_time($baseline_runtime.to_f)}]"

    # generate initial configuration by calling fpconf
    # and initialize global data structures
    print "Generating initial configuration ... "
    $stdout.flush
    orig_cfg = File.open($orig_config_name, "w")
    puts "initial: #{$initial_cfg_fn}"
    if $initial_cfg_fn.length > 0 && File.exists?($initial_cfg_fn) then
        IO.foreach($initial_cfg_fn) do |io|
            io.each_line do |line|
                orig_cfg.puts line
            end
        end
    else
        IO.popen("fpconf #{$binary_path}") do |io|
            io.each_line do |line|
                orig_cfg.puts line
            end
        end
    end
    orig_cfg.close
    mod = nil
    func = nil
    bblk = nil
    IO.foreach($orig_config_name) do |io|
        io.each_line do |line|
            if line =~ /MODULE.*\"(.+)\"/ then
                mod = SingleReplacementConfig.new($1, "mod", line[1,1])
                $all_cfgs[mod.key] = mod
            end
            if line =~ /FUNC.*\"(.+)\"/ then
                func = SingleReplacementConfig.new($1, "func", line[1,1])
                $all_cfgs[func.key] = func
                mod.children << func.key if mod != nil
                mod.rcount  += func.rcount if mod != nil
            end
            if line =~ /BBLK #\d+: 0x([0-9A-Fa-f]+)/ then
                bblk = SingleReplacementConfig.new($1, "bblk", line[1,1])
                $all_cfgs[bblk.key] = bblk
                func.children << bblk.key if func != nil
                func.rcount += bblk.rcount if func != nil
                mod.rcount  += bblk.rcount if mod != nil
            end
            if line =~ /INSN #\d+: 0x([0-9A-Fa-f]+)/ then
                insn = SingleReplacementConfig.new($1, "insn", line[1,1])
                $all_cfgs[insn.key] = insn
                bblk.children << insn.key if bblk != nil
                bblk.ccount += insn.ccount if bblk != nil
                func.ccount += insn.ccount if func != nil
                mod.ccount  += insn.ccount if mod != nil
                bblk.rcount += insn.rcount if bblk != nil
                func.rcount += insn.rcount if func != nil
                mod.rcount  += insn.rcount if mod != nil
            end
        end
    end
    puts "done."

    # throw away empty configs
    to_delete = Array.new
    $all_cfgs.each_pair do |key, cfg|
        to_delete << key if cfg.ccount == 0
    end
    to_delete.each do |key|
        $all_cfgs.delete(key)
    end

    # save project config to file (for workers to load)
    save_all_configs

    # initialize work queue
    # start by trying all modules
    count = 0
    $all_cfgs.each_pair do |key, cfg|
        # FOR TESTING: limit to five
        #if cfg.type == "mod" && cfg.ccount > 0 && count < 5
        if cfg.type == "mod" && cfg.ccount > 0 &&
                (cfg.initial == " " || cfg.initial == "c") then
            puts "Adding config #{cfg.key} to workqueue"
            add_to_workqueue(cfg.key)
            count += 1
        end
    end
    $max_queue_length = get_workqueue_length

end
# }}}

# {{{ run_main_autoconf_loop
def run_main_autoconf_loop
    key = get_next_workqueue_item

    # main search loop
    while !key.nil? && key != "" do

        add_to_inproc(key)

        # grab configuration object
        cfg = $all_cfgs[key]

        # queue status output
        queue_length = get_workqueue_length
        $status_buffer += "[Queue length: #{"%3d" % (queue_length+1)}]  "
        $max_queue_length = queue_length if queue_length > $max_queue_length

        puts "Testing config #{cfg.key}: ccount=#{cfg.ccount} rcount=#{cfg.rcount}"

        if cfg.rcount == 0 && run_config(cfg) then

            # this config passed; add it to the final
            add_final_regexp(cfg.regexp)

        else

            # add any children we need to test
            if (cfg.type == "mod"  && cfg.ccount >= 1) ||
               (cfg.type == "func" && cfg.ccount >= 1) ||
               (cfg.type == "bblk" && cfg.ccount >= 2) then
                cfg.children.each do |ckey|
                    child = $all_cfgs[ckey]
                    if child != nil && child.ccount > 0 &&
                            (child.initial == " " || child.initial == "c") then
                        puts "Adding config #{ckey} to workqueue"
                        add_to_workqueue(ckey)
                    end
                end
            end

        end

        add_to_tested(key)
        remove_from_inproc(key)
        key = get_next_workqueue_item
    end

end
# }}}

# {{{ run_main_supervisor_loop
def run_main_supervisor_loop
    while get_workqueue_length > 0 or get_inproc_length > 0 do
        while get_workqueue_length > 0 do

            # restart any dead worker processes
            if !$is_worker && get_workqueue_length > 0 then
                $workers.each_pair do |job, dir|
                    cmd = "ps -o s= p #{job.to_i}"
                    stat = `#{cmd}`
                    stat.chomp!
                    if stat != "S" then
                        $workers.delete(job)
                        id = File.basename(dir)
                        if id =~ /worker(\d+)/ then
                            id = $1
                        else
                            id = id[$binary_name.length+1,id.length-$binary_name.length-1]
                        end
                        puts "Respawning worker #{id} ..."
                        FileUtils.rm_rf(dir)
                        Dir.mkdir(dir)
                        job = fork do
                            exec "cd #{dir} && #{$self_invoke} -w #{$autoconf_path}"
                        end
                        $workers[job] = dir
                    end
                end
            end

            # wait a while
            sleep 5
        end

        # clean up any workers and directories
        $workers.each_pair do |job, dir|
            Process.wait(job.to_i)
            FileUtils.rm_rf(dir)
        end
        #begin
            #Dir.glob("*").each do |fn|
                #if fn =~ Regexp.new("^#{$binary_name}_\\d+_worker\\d+$") then
                    #FileUtils.rm_rf(fn)
                #end
            #end
        #rescue
            #puts "Error clearing old worker directories"
        #end

        # move any unfinished configs back to the workqueue
        if get_inproc_length > 0 then
            puts "Unfinished jobs; restarting workers ..."
            move_all_inproc_to_workqueue
        end
    end
end
# }}}

# {{{ finalize_autoconf
def finalize_autoconf

    if File.exist?($final_path) then
        # another process is already finalizing
        puts "Finalization already underway."
        return
    else
        Dir.mkdir($final_path)
    end

    # queue status output
    puts "Candidate queue exhausted.  [Max queue length: ~#{$max_queue_length} item(s)]"

    # generate final config file
    final_config_regexps = load_final_regexps
    print "Generating final configuration ... "
    $stdout.flush
    final_config = File.open($final_config_name, "w")
    IO.foreach($orig_config_name) do |line|
        line_found = false
        final_config_regexps.each do |reg|
            if !line_found && line =~ reg then
                final_config.puts "^#{$stat_preferred}#{line[2,line.size-1]}"
                line_found = true
            end
        end
        if !line_found then
            if line =~ /^\^c/ then
                final_config.puts "^#{$stat_alternate}#{line[2,line.size-1]}"
            else
                final_config.puts line
            end
        end
    end
    final_config.close
    FileUtils.cp($final_config_name, $final_path)
    puts "done."

    # find best individual configs
    kept_configs = Array.new
    mainlog = load_mainlog
    cur_cfg = ""
    inst_item = ["",0.0]
    exec_item = ["",0.0]
    inst_hash = Array.new
    exec_hash = Array.new
    mainlog.each do |line|
        if line =~ /Finished (.*\.cfg):/ then
            cur_cfg = $1
            inst_item = ["",0.0]
            exec_item = ["",0.0]
            has_exec = false
        end
        if line =~ /instrumented .* \[([\d.]*)%\] single/ then
            inst_item = [cur_cfg, inst_item[1]+$1.to_f]
        end
        if line =~ /executed .* \[([\d.]*)%\] single/ then
            exec_item = [cur_cfg, exec_item[1]+$1.to_f]
        end
        if line =~ /Success!/ then
            inst_hash << inst_item
            exec_hash << exec_item
        end
    end
    inst_hash = inst_hash.sort_by { |cfg,pct| -pct }
    exec_hash = exec_hash.sort_by { |cfg,pct| -pct }
    report = Array.new
    report << " "
    report << "Top %-15s%15s  %s"%["instrumented:","CONFIG","% REPLACED"]
    10.times do
        entry = inst_hash.shift
        if !entry.nil? then
            report << "    %30s  %4.1f"%[entry[0],entry[1]]
            kept_configs << "#{$binary_name}#{entry[0]}"
        end
    end
    report << " "
    report << "Top %-15s%15s  %s"%["executed:","CONFIG","% REPLACED"]
    10.times do
        entry = exec_hash.shift
        if !entry.nil? then
            report << "    %30s  %4.1f"%[entry[0],entry[1]]
            kept_configs << "#{$binary_name}#{entry[0]}"
        end
    end
    report << " "
    add_to_mainlog(report.join("\n"))

    # try the final config (and keep results)
    Dir.chdir($final_path)
    run_config_file($final_config_name, true)
    Dir.chdir($autoconf_path)

    # clean all config and temporary files
    $all_cfgs.each_pair do |key, cfg|
        File.delete(cfg.filename) if File.exists?(cfg.filename) and not kept_configs.include?(cfg.filename)
    end
    #File.delete($settings_fn)
    #File.delete($allconfigs_fn)
    File.delete($workqueue_fn)
    File.delete($inproc_fn)
    #File.delete($finalregexps_fn)

    elapsed = Time.now.to_f - $start_time.to_f
    puts "Done.  [Total configs tested: #{get_tested_length}]  [Elapsed walltime: #{format_time(elapsed)}]"

end
# }}}

# {{{ configuration test helpers

# build and run a configuration (takes a configuration object)
def run_config (cfg)

    # write configuration file
    cfg_path = $autoconf_path + cfg.filename
    f = File.new(cfg_path, "w")
    IO.foreach($orig_config_name) do |line|
        if line =~ cfg.regexp then
            f.puts "^#{$stat_preferred}#{line[2,line.size-1]}"
        elsif line =~ /^\^c/ then
            f.puts "^#{$stat_alternate}#{line[2,line.size-1]}"
        else
            f.puts line
        end
    end
    f.close

    # pass off to filename version
    return run_config_file(cfg_path, false)
end

# build and run a configuration (takes a .cfg filename)
def run_config_file (fn, keep)

    # status updates
    basename = File.basename(fn)
    basename = basename[$binary_name.length, basename.length-$binary_name.length]
    puts "Testing #{basename} ..."
    $status_buffer = "    Finished #{basename}:\n"

    # build rewritten mutatee
    cmd = "fpinst -i #{$fortran_mode ? "-N" : ""}"
    cmd += " -c #{fn}"
    cmd += " #{$binary_path}"
    #add_to_mainlog("    Building mutatee for #{basename}: #{cmd}")
    Open3.popen3(cmd) do |io_in, io_out, io_err, io_wait|
        io_out.each_line do |line|
            if line =~ /Inplace: (.*)$/ then
                $status_buffer += "        #{$1}\n"
            end
        end
    end

    # execute rewritten mutatee and check for success
    passed = false
    runtime = 0
    error = 0.0
    cmd = "#{$autoconf_path}#{$craft_driver} #{Dir.getwd}/mutant"
    #add_to_mainlog("    Testing mutatee for #{basename}: #{cmd}")
    Open3.popen3(cmd) do |io_in, io_out, io_err, io_wait|
        io_out.each_line do |line|
            if line =~ /status:\s*(pass|fail)/i then
                if $1 =~ /pass/i then
                    passed = true
                end
            elsif line =~ /error:\s*(.+)/i then
                error = $1.to_f
            elsif line =~ /time:\s*(.+)/i then
                runtime = $1.to_i
            end
        end
    end

    # scan log file(s) for info
    Dir.glob("*.log").each do |fn|
        if fn != "fpinst.log" then
            IO.foreach(fn) do |line|
                if line =~ /Inplace: (.*)$/ then
                    $status_buffer += "        #{$1.gsub(/<.*>/, "")}\n"
                end
            end
        end
    end

    # print output
    if passed then
        $status_buffer += "        Success!"
    else
        $status_buffer += "        FAILED!"
    end
    $status_buffer += "  [Walltime: #{format_time(runtime.to_f)}"
    $status_buffer += " %.1fX"%[runtime / $baseline_runtime.to_f]
    $status_buffer += " Error: %g]"%[error]
    puts $status_buffer
    add_to_mainlog($status_buffer)
    $status_buffer = ""

    # clean out mutant, logs, and rewritten library files
    if !keep then
        begin
            Dir.glob("*").each do |fn|
                if fn =~ /mutant/ || fn =~ /\.log/ || fn =~ /lib(c|m)\.so\.6/ then
                    File.delete(fn)
                end
            end
        rescue
            puts "Error clearing old files"
        end
    end

    return passed
end

# }}}

# {{{ file helpers

def save_all_configs
    f = File.new($settings_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.puts $start_time.to_i
    f.puts $binary_name
    f.puts $binary_path
    f.puts $stat_preferred
    f.puts $stat_alternate
    f.puts $baseline_runtime
    f.puts($fortran_mode ? "fortran" : "other")
    f.puts $initial_cfg_fn
    f.close
    f = File.new($allconfigs_fn, File::RDWR)
    f.flock File::LOCK_EX
    YAML.dump($all_cfgs, f)
    f.close
end
def load_all_configs
    # could probably be read-only
    f = File.new($settings_fn, File::RDWR)
    f.flock File::LOCK_EX
    $start_time = Time.at(f.gets.to_i)
    $binary_name = f.gets.chomp
    $binary_path = f.gets.chomp
    $stat_preferred = f.gets.chomp
    $stat_alternate = f.gets.chomp
    $baseline_runtime = f.gets.chomp.to_i
    lang = f.gets.chomp
    if lang == "fortran" then
        $fortran_mode = true
    else
        $fortran_mode = false
    end
    $initial_cfg_fn = f.gets.chomp
    f.close
    # could probably be read-only
    f = File.new($allconfigs_fn, File::RDWR)
    f.flock File::LOCK_EX
    $all_cfgs = YAML.load(f)
    f.close
end


def add_to_workqueue(item)
    f = File.new($workqueue_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(item)
    f.close
end
def get_next_workqueue_item
    item = ""
    workqueue = Array.new
    f = File.new($workqueue_fn, File::RDWR)
    f.flock File::LOCK_EX
    workqueue = f.readlines
    item = workqueue.shift
    f.pos = 0
    f.print workqueue
    f.truncate(f.pos)
    f.close
    if !item.nil? then
        item.chomp!
    end
    return item
end
def get_workqueue_length
    # could probably be read-only
    f = File.new($workqueue_fn, File::RDWR)
    f.flock File::LOCK_EX
    workqueue = f.readlines
    f.close
    return workqueue.size
end


def add_to_inproc(item)
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(item)
    f.close
end
def remove_from_inproc(item)
    inproc = Array.new
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    inproc = f.readlines
    inproc.each do |ipitem|
        if ipitem.chomp == item then
            inproc.delete(ipitem)
        end
    end
    f.pos = 0
    f.print inproc
    f.truncate(f.pos)
    f.close
end
def get_inproc_length
    # could probably be read-only
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    inproc = f.readlines
    f.close
    return inproc.size
end
def move_all_inproc_to_workqueue
    inproc = Array.new
    f = File.new($inproc_fn, File::RDWR)
    f.flock File::LOCK_EX
    inproc = f.readlines
    f.close
    inproc.each do |item|
        remove_from_inproc(item.chomp)
        add_to_workqueue(item.chomp)
    end
end


def add_to_tested(item)
    f = File.new($tested_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(item)
    f.close
end
def get_tested_length
    # could probably be read-only
    f = File.new($tested_fn, File::RDWR)
    f.flock File::LOCK_EX
    tested = f.readlines
    f.close
    return tested.size
end


def add_final_regexp(reg)
    f = File.new($finalregexps_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(reg.to_s)
    f.close
end
def load_final_regexps
    # could probably be read-only
    f = File.new($finalregexps_fn,  File::RDWR)
    f.flock File::LOCK_EX
    lines = f.readlines
    f.close
    final_config_regexps = Array.new
    lines.each do |line|
        final_config_regexps << Regexp.new(line.chomp)
    end
    return final_config_regexps
end


def add_to_mainlog(reg)
    f = File.new($mainlog_fn, File::RDWR)
    f.flock File::LOCK_EX
    f.seek(0,IO::SEEK_END)
    f.puts(reg.to_s)
    f.close
end
def load_mainlog
    # could probably be read-only
    f = File.new($mainlog_fn,  File::RDWR)
    f.flock File::LOCK_EX
    lines = f.readlines
    f.close
    return lines
end

# }}}

# {{{ misc helpers
def format_time (elapsed)
    mins, secs = elapsed.divmod 60.0
    hrs, mins = mins.divmod 60.0
    #return "%d:%02d:%05.2f"%[hrs.to_i, mins.to_i, secs]
    return "%d:%02d:%02d"%[hrs.to_i, mins.to_i, secs.to_i]
end
# }}}

main

