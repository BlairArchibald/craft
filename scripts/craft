#!/usr/bin/ruby
#
# craft
#
# Generate floating-point precision configurations for a target binary, and test
# them. Assemble a final recommended configuration. Based on "fpautoconf" and
# improved to be far more generic and robust.
#
# Mike Lam, UMD
# October 2012
#

# needed for opening stderr as well as stdin/stdout
# when spawning new system processes
require 'open3.rb'

# needed for object serialization
require 'yaml.rb'

# needed for file manipulation and directory removal
require 'fileutils.rb'


# {{{ top-level: global constants

$RESULT_PASS  = "Success!"                          # test result possibilities
$RESULT_FAIL  = "FAILED!"
$RESULT_ERROR = "ERROR!!!"

$TYPE_APPLICATION = "APPLICATION"                   # control point levels
$TYPE_MODULE      = "MODULE"
$TYPE_FUNCTION    = "FUNC"
$TYPE_BASICBLOCK  = "BBLK"
$TYPE_INSTRUCTION = "INSN"
$TYPE_SPACES = Hash.new("")
$TYPE_SPACES[$TYPE_APPLICATION] = ""                # for pretty output
$TYPE_SPACES[$TYPE_MODULE]      = "  "
$TYPE_SPACES[$TYPE_FUNCTION]    = "    "
$TYPE_SPACES[$TYPE_BASICBLOCK]  = "      "
$TYPE_SPACES[$TYPE_INSTRUCTION] = "        "
$TYPE_RANK = Hash.new(0)
$TYPE_RANK[$TYPE_APPLICATION] = 1
$TYPE_RANK[$TYPE_MODULE]      = 2
$TYPE_RANK[$TYPE_FUNCTION]    = 3
$TYPE_RANK[$TYPE_BASICBLOCK]  = 4
$TYPE_RANK[$TYPE_INSTRUCTION] = 5
$TYPE_RRANK = $TYPE_RANK.invert

$STATUS_NONE      = " "                             # replacement status posibilities
$STATUS_SINGLE    = "s"
$STATUS_DOUBLE    = "d"
$STATUS_IGNORE    = "i"
$STATUS_CANDIDATE = "c"

$FINALCFG_CUID = "FINAL"                            # special config; represents "best" final results

# }}}


# PPoint
#
# Represents a single control point in a program. There is a single APPLICATION
# PPoint at the root, and then it branches into modules, functions, etc. This
# keeps the entire program's structure in memory while only requiring a single
# copy (as older versions of this script did). The PPoint knows how to output
# actual configuration files (given a AppConfig object) that the mutator can use.
#
# {{{ PPoint
class PPoint
    attr_accessor :uid              # unique regex identifier; e.g. "INSN #34: 0x804d3f"
    attr_accessor :type             # module, function, instruction, etc.
    attr_accessor :orig_status      # single, double, ignore, candidate, none
    attr_accessor :parent           # PPoint
    attr_accessor :children         # array of PPoints
    attr_accessor :attrs            # string => string
    attr_accessor :byuid            # uid => PPoint          (for increased lookup speed)
    attr_accessor :byaddr           # addr => insn PPoint    (for increased lookup speed)

    def initialize (uid, type, orig_status)
        @uid = uid
        @type = type
        @orig_status = orig_status
        @parent = nil
        @children = Array.new
        @attrs = Hash.new
        @byuid = Hash.new
        @byaddr = Hash.new
    end

    def build_config_file (config, fn)
        # write out a configuration file for this program and the given config
        # this method will only be called in an APPLICATION node; it calls
        # output() to recursively print the other levels
        fout = File.new(fn, "w")
        if @attrs.has_key?("prolog") then
            fout << @attrs["prolog"]
        end
        output(config, fout, nil)
        fout.close
    end

    def build_lookup_hash(pt=nil)
        if pt.nil? then
            @byuid[@uid] = self
            @children.each do |child|
                build_lookup_hash(child)
            end
        else
            if pt.type == $TYPE_INSTRUCTION and pt.attrs.has_key?("addr") then
                @byaddr[pt.attrs["addr"]] = pt
            end
            @byuid[pt.uid] = pt
            pt.children.each do |child|
                build_lookup_hash(child)
            end
        end
    end

    def lookup_by_uid(uid)
        return @byuid[uid]
    end

    def lookup_by_addr(addr)
        return @byaddr[addr]
    end

    def build_cuid
        # build config unique id
        label = @uid
        if @uid =~ /APPLICATION/ then
            label = "APP #{@attrs["desc"]}"
        elsif @uid =~ /MODULE/ then
            label = "MOD #{@attrs["desc"]}"
        elsif @uid =~ /FUNC/ then
            label = "FUNC #{@attrs["desc"]}"
        elsif @uid =~ /BBLK/ then
            label = "BBLK #{@attrs["addr"]}"
        elsif @uid =~ /INSN/ then
            label = "INSN #{@attrs["addr"]}"
        end
        return label
    end

    def build_label
        # build human-readable label
        label = @uid
        if @uid =~ /APPLICATION/ then
            label = "APP #{@attrs["desc"]}"
        elsif @uid =~ /MODULE/ then
            label = "MOD #{@attrs["desc"]}"
        elsif @uid =~ /FUNC/ then
            label = "FUNC #{@attrs["desc"]}"
        elsif @uid =~ /BBLK/ then
            label = "BBLK #{@attrs["addr"]}"
        elsif @uid =~ /INSN/ then
            label = "INSN #{@attrs["addr"]} \"#{@attrs["desc"]}\""
        end
        return label
    end


    def output (config, fout, overload)
        fout.print("^")
        if type == $TYPE_INSTRUCTION then
            if @orig_status == $STATUS_CANDIDATE then
                # candidate for replacement; check to see if we should
                if not overload.nil? then
                    # status overridden by something higher up the tree
                    fout.print(overload)
                else
                    if config.exceptions.has_key?(@uid) then
                        # status overridden by current config
                        fout.print(config.exceptions[@uid])
                    else
                        # no override; output configuration default
                        fout.print(config.default)
                    end
                end
            else
                fout.print(@orig_status)
            end
        else
            if overload.nil? then
                if config.exceptions.has_key?(@uid) then
                    # children status overridden by current config
                    overload = config.exceptions[@uid]
                elsif not @orig_status == $STATUS_NONE then
                    # children status overridden by original config
                    overload = @orig_status
                end
            end
        end
        fout.print("  ")
        fout.print($TYPE_SPACES[@type])     # indentation
        fout.print(@uid)
        if @attrs.has_key?("desc") then
            fout.print(" \"")
            fout.print(@attrs["desc"])
            fout.print("\"")
        end
        fout.print("\n")
        @children.each do |pt|
            pt.output(config, fout, overload)
        end
    end
end # }}}


# AppConfig
#
# Represents a particular replacement configuration. To save space, an
# exception-based scheme is used; it keeps a "default" replacement status for
# all instructions that are not covered by an exception. Any exceptions at a
# level higher than an instruction (module, function, etc.) propogate to
# lower levels.
#
# {{{ AppConfig
class AppConfig
    attr_accessor :cuid             # unique identifier (string)
    attr_accessor :label            # human-readable description; e.g. "MODULE #1: boxes.c; MODULE #2: spheres.c"
    attr_accessor :default          # status
    attr_accessor :exceptions       # cuid -> status
    attr_accessor :attrs            # string => string

    def initialize (cuid, label, default)
        @cuid = cuid
        @label = label
        @default = default
        @exceptions = Hash.new
        @attrs = Hash.new
    end

    def <=> (c2)
        result = nil

        # ascending level rank -> descending executed %
        if attrs.has_key?("level") and c2.attrs.has_key?("level") then
            l1 = attrs["level"]
            l2 = c2.attrs["level"]
            if l1 == l2 then
                if attrs.has_key?("orig_cinst") and c2.attrs.has_key?("orig_cinst") then
                    oc1 = attrs["orig_cinst"].to_f
                    oc2 = c2.attrs["orig_cinst"].to_f
                    if oc1 == oc2 then
                        result = -1
                    else
                        result = oc2 <=> oc1
                    end
                else
                    result = -1
                end
            else
                result = $TYPE_RANK[l1] <=> $TYPE_RANK[l2]
            end
        else
            result = -1
        end

        # descending instrumented % + executed %
        if attrs.has_key?("orig_icount") and c2.attrs.has_key?("orig_icount") and
           attrs.has_key?("orig_cinst") and c2.attrs.has_key?("orig_cinst") then
            oi1 = attrs["orig_icount"].to_f
            oi2 = c2.attrs["orig_icount"].to_f
            oc1 = attrs["orig_cinst"].to_f
            oc2 = c2.attrs["orig_cinst"].to_f
            result = (oi2+oc2) <=> (oi1+oc1)
        end

        return result
    end

    def filename
        # sanitize cuid
        fn = ""
        @cuid.each_char do |c|
            if c =~ /[0-9a-zA-Z_]/ then
                fn << c.downcase
            elsif c == ' ' then
                fn << "_"
            end
        end
        fn << ".cfg"
        return fn
    end
end # }}}


# Strategy
#
# Provides rules and procedures governing the search process. This class is
# intended to be inherited and overloaded; this particular implementation does a
# very simple, naive, breadth-first search through the application. It also has
# two simple optimizations:
#
#   1) Ignore program control branches that do not contain any FP instructions
#   2) Ignore program control branches that only have a single child (just do
#      that one instead)
#
# {{{ Strategy
class Strategy
    attr_accessor :program
    attr_accessor :preferred
    attr_accessor :alternate

    def initialize(program, pref, alt)
        @preferred = pref
        @alternate = alt
        @program = program
        update_icount(@program)
    end

    def update_icount(point)
        # allow us to ignore branches of the program that don't actually contain
        # any FP instructions
        total = 0
        point.children.each do |child|
            update_icount(child)
            total += child.attrs["icount"].to_i
        end
        if point.type == $TYPE_INSTRUCTION and point.orig_status == $STATUS_CANDIDATE then
            total += 1
        end
        point.attrs["icount"] = total.to_s
    end

    def build_initial_configs
        # try to replace the entire program
        configs = Array.new
        cfg = AppConfig.new(@program.build_cuid, @program.build_label, @alternate)
        cfg.exceptions[@program.uid] = @preferred
        cfg.attrs["level"] = $TYPE_APPLICATION
        configs << cfg
        return configs
    end

    def split_config(config)
        # add a config for each child node of each exception
        configs = Array.new
        config.exceptions.each_pair do |k,v|
            pt = @program.lookup_by_uid(k)
            pt.children.each do |child|

                # skip nodes with no FP instructions
                if child.attrs["icount"].to_i > 0 then
                    child_pt = child

                    # skip single-child nodes
                    if child.children.size == 1 then
                        child_pt = child.children.first
                    end

                    cfg = AppConfig.new(child_pt.build_cuid, child_pt.build_label, config.default)
                    cfg.exceptions[child_pt.uid] = v
                    cfg.attrs["level"] = child_pt.type
                    configs << cfg
                end
            end
        end
        return configs
    end

    def build_final_config(results)
        # simple union of all passing configs
        cfg = AppConfig.new($FINALCFG_CUID, "Final Configuration", @alternate)
        results.each do |r|
            if r.attrs.has_key?("result") and r.attrs["result"] == $RESULT_PASS then
                r.exceptions.each_pair do |k,v|
                    if cfg.exceptions.has_key?(k) and not (cfg.exceptions[k] == v) then
                        puts "WARNING: Conflicting results for #{cfg.cuid}: #{cfg.exceptions[k]} and #{v}"
                    end
                    cfg.exceptions[k] = v
                end
            end
        end
        return cfg
    end
end # }}}


# BinaryStrategy
#
# Improved search algorithm that performs a binary search on failed configs
# rather than immediately adding all subchild configs to the queue. It also
# prioritizes new configs using the profiling results.
#
# {{{ BinaryStrategy
class BinaryStrategy < Strategy
    attr_accessor :basetype

    def split_config(config)
        configs = Array.new
        all_insns = true

        # build list of new configurations
        if config.exceptions.size > 1 then

            # last config tried multiple exceptions;
            # add a config for each exception and try again
            config.exceptions.each_pair do |k,v|
                pt = @program.lookup_by_uid(k)
                cfg = AppConfig.new(pt.build_cuid, pt.build_label, config.default)
                cfg.exceptions[pt.uid] = v
                if pt.attrs.has_key?("cinst") then
                    cfg.attrs["cinst"] = pt.attrs["cinst"]
                else
                    cfg.attrs["cinst"] = 0
                end
                cfg.attrs["level"] = pt.type
                configs << cfg
            end
        else

            # add a config for each child node of the current exception
            config.exceptions.each_pair do |k,v|
                pt = @program.lookup_by_uid(k)
                pt.children.each do |child|

                    # skip nodes with no FP instructions
                    # stop at basic blocks if that's desired
                    if child.attrs["icount"].to_i > 0 then
                        child_pt = child

                        # skip single-child nodes
                        if child.children.size == 1 and child.type != @basetype then
                            child_pt = child.children.first
                        end

                        if not (child_pt.type == $TYPE_INSTRUCTION) then
                            all_insns = false
                        end

                        cfg = AppConfig.new(child_pt.build_cuid, child_pt.build_label, config.default)
                        #puts "ADDING #{cfg.cuid} #{child_pt.type}"
                        cfg.exceptions[child_pt.uid] = v
                        if child_pt.attrs.has_key?("cinst") then
                            cfg.attrs["cinst"] = child_pt.attrs["cinst"]
                        else
                            cfg.attrs["cinst"] = 0
                        end
                        cfg.attrs["level"] = child_pt.type
                        configs << cfg
                    end
                end
            end
        end

        # sort in descending order of instruction executions
        # don't do this if we just have a bunch of instruction configs
        if not all_insns then
            configs.sort! { |c1, c2| c2.attrs["cinst"].to_i <=> c1.attrs["cinst"].to_i }
            #puts "Sorting #{configs.size} at #{config.cuid}"
        end

        # merge into two (binary search) if we have a lot of new configs
        if configs.size > 5 then
            pivot = configs.size / 2
            left_cfg  = AppConfig.new(config.cuid + " LEFT",  config.label + " LEFT",  config.default)
            right_cfg = AppConfig.new(config.cuid + " RIGHT", config.label + " RIGHT", config.default)
            left_cfg.attrs["cinst"]  = "0"
            right_cfg.attrs["cinst"] = "0"
            configs.each do |cfg|
                cfg.exceptions.each_pair do |k,v|
                    if pivot > 0 then
                        left_cfg.exceptions[k] = v
                        if cfg.attrs.has_key?("cinst") then
                            left_cfg.attrs["cinst"] = (left_cfg.attrs["cinst"].to_i + cfg.attrs["cinst"].to_i).to_s
                        end
                    else
                        right_cfg.exceptions[k] = v
                        if cfg.attrs.has_key?("cinst") then
                            right_cfg.attrs["cinst"] = (right_cfg.attrs["cinst"].to_i + cfg.attrs["cinst"].to_i).to_s
                        end
                    end
                end
                pivot -= 1
            end
            left_cfg.attrs["level"]  = config.attrs["level"]
            right_cfg.attrs["level"] = config.attrs["level"]
            configs = Array.new
            configs << left_cfg
            configs << right_cfg
        end
        return configs
    end
end # }}}


# App entry point

# {{{ main method
def main
    srand

    # initialize global variables
    $search_tag = "craft"                   # filename tag
    $craft_driver = "craft_driver"          # standard driver program name
    $status_preferred = $STATUS_SINGLE      # preferred replacement status
    $status_alternate = $STATUS_DOUBLE      # replacement status if cannot be preferred
    $status_ignored = $STATUS_IGNORE        # "cannot instrument" replacement status
    $status_blank = " "                     # "no result" replacement status
    $fortran_mode = false                   # pass "-N" to mutator
    $base_type = $TYPE_INSTRUCTION          # stop splitting configs at this level
    $initial_cfg_fn = ""                    # initial config filename (may be blank)
    $max_queue_length = 0                   # track largest queue size (approximate)
    $main_mode = "start"                    # main status ("start/search", "resume", "status", "clean", "worker", "help")
    $restart_inproc = false                 # resume by restarting all inprocess tests
    $resume_lower = false                   # resume at a lower level
    $num_workers = 1                        # number of worker threads
    $workers = Hash.new                     # worker proc info (pid => dirname)
    $status_buffer = ""                     # buffer for output (keeps multiprocess output clean)
    $strategy_name = "bin_simple"           # desired search strategy
    $self_invoke = File.basename($0)        # used to spawn worker threads
    $fpconf_invoke = "fpconf"               # invoke configuration generator
    $fpconf_options = ""                    # configuration generator options
    $fpinst_invoke = "fpinst"               # invoke mutator

    # check command-line options
    if ARGV.size == 0 or ARGV.include?("-h") then
        $main_mode = "help"
        print_usage
        exit
    end

    parse_command_line
    
    # cleaning mode
    if $main_mode == "clean" then
        puts "Cleaning..."
        clean_everything
        puts "Done."
        exit
    end

    # set up environment and filenames
    if $main_mode != "worker" then
        $search_path = Dir.getwd + "/"

        # this really should happen BEFORE parse_command_line so that the
        # command-line parameters will override the craft_driver options, but
        # the worker threads shouldn't read the craft_driver since the options
        # are saved in the settings files, but we don't know if we're a worker
        # until we parse the command-line options
        read_craft_driver
    end

    # plain text info files
    $settings_fn = "#{$search_path}#{$search_tag}.settings"
    $program_fn = "#{$search_path}#{$search_tag}.program"
    $mainlog_fn = "#{$search_path}#{$search_tag}.mainlog"
    $walltime_fn = "#{$search_path}#{$search_tag}.walltime"

    # files containing lists of AppConfig objects
    $workqueue_fn = "#{$search_path}#{$search_tag}.workqueue"     # waiting to be tested
    $inproc_fn = "#{$search_path}#{$search_tag}.inproc"           # currently running
    $tested_fn = "#{$search_path}#{$search_tag}.tested"           # finished (passed, failed, or aborted)

    # important single configuration files
    $orig_config_fn = "#{$search_path}craft_orig.cfg"
    $final_config_fn = "#{$search_path}craft_final.cfg"

    # configuration file directories
    $perf_path     = "#{$search_path}baseline/"    # baseline performance test
    $prof_path     = "#{$search_path}profile/"     # profiler run
    $final_path    = "#{$search_path}final/"       # single final "best" config (cfg file + mutant)
    $best_path     = "#{$search_path}best/"        # top 10 "best" individual configs (cfg files only)
    $passed_path   = "#{$search_path}passed/"      # all successful configs (cfg files only)
    $failed_path   = "#{$search_path}failed/"      # all failed configs (cfg files only)
    $aborted_path  = "#{$search_path}aborted/"     # all aborted configs (cfg files only)
    $snapshot_path = "#{$search_path}snapshots/"   # status printouts

    if $main_mode == "status" then
        print_status
        exit
    end

    # check for driver script
    if !File.exist?("#{$search_path}#{$craft_driver}") then
        puts "No driver program \"craft_driver\" found."
        puts "Aborting."
        exit
    end

    if $main_mode == "worker" then

        # this is just a worker process
        
        load_settings
        initialize_program
        read_profiler_data
        initialize_strategy
        run_main_search_loop                      # main loop
        #puts "Worker finished.  [Empty queue]"

    else

        # this is a supervisor process

        puts ""
        puts "CRAFT"
        puts "Autoconfiguring #{$binary_name} ..."
        puts "Working dir: #{$search_path}"

        if $main_mode == "start" then
            # this is the first invocation of this analysis; initialize everything
            initialize_search
        else
            # we're resuming an analysis
            puts "Resuming in-process search ..."
            if File.exist?($final_path) then
                # clear out any final configuration testing
                FileUtils.rm_rf($final_path)
            end
            if File.exist?($walltime_fn) then
                # previous search was completed; restart wall timer
                $start_time = Time.now
                FileUtils.rm_rf($walltime_fn)
            end
            load_settings
            initialize_program
            read_profiler_data
            initialize_strategy
            if $restart_inproc then
                toDelete = Array.new
                Dir.glob("*_worker*") do |fn| toDelete << fn end
                toDelete.each do |f| FileUtils.rm_rf(f) end
                move_all_inproc_to_workqueue
            end
            if $resume_lower then
                resume_lower_search
                save_settings
            end
        end

        # set up worker thread folders
        $num_workers.times do |id|
            worker_dir = "#{$search_path + $binary_name}_#{Process.pid}_worker#{id}"
            if File.exist?(worker_dir) then
                FileUtils.rm_rf(worker_dir)
            end
            Dir.mkdir(worker_dir)
            $workers[id] = worker_dir
        end

        # spawn worker threads (don't spawn more than we need right now, though)
        [get_workqueue_length, $num_workers].min.times do |id|
            worker_dir = "#{$search_path + $binary_name}_#{Process.pid}_worker#{id}"
            job = fork do
                exec "cd #{worker_dir} && #{$self_invoke} worker #{id} #{$search_path}"
            end
            $workers.delete(id)
            $workers[job] = worker_dir
            #puts "Spawned worker thread #{id} (pid=#{job})."
        end

        # main loop
        puts "Initialization complete. Starting main search routine."
        puts ""
        run_main_supervisor_loop

        # test final config, assemble results, etc.
        finalize_search

    end
end # }}}


# Search management routines

# {{{ initialize_search
def initialize_search
    # supervisor initialization
    
    $start_time = Time.now

    # create search config files
    File.new($settings_fn, "w").close
    File.new($workqueue_fn, "w").close
    File.new($inproc_fn, "w").close
    File.new($tested_fn, "w").close
    File.new($mainlog_fn, "w").close

    # initial performance run
    print "Performing baseline performance test ... "
    $stdout.flush
    if !run_baseline_performance then
        puts "Baseline performance test failed verification!"
        puts "Aborting search."
        exit
    end
    puts " [Base error: #{$baseline_error}  walltime: #{format_time($baseline_runtime.to_f)}]"

    # generate initial configuration by calling fpconf
    # and initialize global data structures
    print "Generating initial configuration ... "
    $stdout.flush
    orig_cfg = File.open($orig_config_fn, "w")
    if $initial_cfg_fn.length > 0 && File.exists?($initial_cfg_fn) then
        # a base config was given; just read it
        print "(using base: #{$initial_cfg_fn}) "
        $stdout.flush
        IO.foreach($initial_cfg_fn) do |line|
            orig_cfg.puts line
        end
    else
        # run fpconf to generate config
        IO.popen("#{$fpconf_invoke} #{$fpconf_options} #{$binary_path}") do |io|
            io.each_line do |line|
                orig_cfg.puts line
            end
        end
    end
    Dir.glob("fpconf.log").each do |f| File.delete(f) end
    orig_cfg.close
    puts "done."

    # read all program control points and baseline performance data
    # depends on initial configuration being present
    initialize_program

    # initial profiling run
    # depends on $program being initialized
    print "Performing profiling test ... "
    $stdout.flush
    if !run_profiler then
        puts "Baseline profiling test failed verification!"
        puts "Aborting search."
        exit
    end
    read_profiler_data
    puts "done."

    # initialize strategy object
    # depends on $program being initialized
    initialize_strategy

    # save project settings to file (for workers to load)
    save_settings

    # initialize work queue
    configs = $strategy.build_initial_configs
    configs.each do |cfg|
        add_to_workqueue(cfg)
        puts "Added config #{cfg.label} to workqueue."
    end
    $max_queue_length = get_workqueue_length

    # create folders for saving configurations
    FileUtils.rm_rf($best_path)
    Dir.mkdir($best_path)
    FileUtils.rm_rf($passed_path)
    Dir.mkdir($passed_path)
    FileUtils.rm_rf($failed_path)
    Dir.mkdir($failed_path)
    FileUtils.rm_rf($aborted_path)
    Dir.mkdir($aborted_path)

end # }}}
# {{{ resume_lower_search
def resume_lower_search

    # figure out new base type
    old_base_type = $base_type
    new_base_rank = $TYPE_RANK[old_base_type]+1
    if !$TYPE_RRANK.has_key?(new_base_rank) then
        puts "Already at lowest base type."
    else
        puts "Lowering base type from #{$base_type} to #{$TYPE_RRANK[new_base_rank]}."
        $base_type = $TYPE_RRANK[new_base_rank]
        if $strategy_name == "bin_simple" then
            $strategy.basetype = $base_type
        end
    end

    # look for new configurations
    configs = Array.new
    old_configs = get_tested_configs
    old_configs.each do |cfg|
        if cfg.attrs["result"] != $RESULT_PASS and is_single_base(cfg, old_base_type) then
            $strategy.split_config(cfg).each do |c|
                configs << c
            end
        end
    end

    # initialize work queue
    configs.each do |cfg|
        add_to_workqueue(cfg)
        puts "Added config #{cfg.label} to workqueue."
    end
    $max_queue_length = get_workqueue_length

end # }}}
# {{{ run_main_search_loop
def run_main_search_loop
    cfg = get_next_workqueue_item

    # main search loop
    while !cfg.nil? do

        add_to_inproc(cfg)

        # queue status output
        queue_length = get_workqueue_length
        $status_buffer += "[Queue length: #{"%3d" % (queue_length+1)}]  "
        $max_queue_length = queue_length if queue_length > $max_queue_length

        puts "Testing config #{cfg.label} ..."

        if run_config(cfg) == $RESULT_PASS then

            # this config passed

        else

            # check to see if we're at the base type; stop if so
            add_children = true
            if is_single_base(cfg, $base_type) then
                add_children = false
            end

            # add any children we need to test
            if add_children then
                configs = $strategy.split_config(cfg)
                configs.each do |child|
                    add_child = true
                    if child.exceptions.keys.size == 1 then
                        pt = $program.lookup_by_uid(child.exceptions.keys.first)
                        if !pt.nil? and $TYPE_RANK[pt.type] > $TYPE_RANK[$base_type] then
                            add_child = false
                        end
                    end
                    if add_child then
                        add_to_workqueue(child)
                        puts "Added config #{child.label} to workqueue."
                    end
                end
            end

        end

        add_tested_config(cfg)
        remove_from_inproc(cfg)
        rebuild_final_config

        cfg = get_next_workqueue_item
    end
end # }}}
# {{{ run_main_supervisor_loop
def run_main_supervisor_loop

    # keep going until there are no more configs to test
    while get_workqueue_length > 0 or get_inproc_length > 0 do

        keep_running = true
        while keep_running do

            $max_queue_length = get_workqueue_length if get_workqueue_length > $max_queue_length

            # check for dead worker processes
            #print "Checking for dead workers ... "
            dead_workers = Array.new
            $workers.each_pair do |job, dir|
                if job < $num_workers then
                    # this job has never actually been started
                    # (pid < $num_workers)
                    dead_workers << [job, dir]
                else
                    cmd = "ps -o s= p #{job.to_i}"
                    stat = `#{cmd}`
                    stat.chomp!
                    if stat != "S" then
                        dead_workers << [job, dir]
                    end
                end
            end
            #puts "#{dead_workers.size} dead worker(s) found."

            if dead_workers.size == $num_workers and get_workqueue_length == 0 then

                # everyone's done and there's nothing else in the queue
                keep_running = false

            elsif get_workqueue_length > 0 then

                # there's still stuff to do; restart dead workers
                [get_workqueue_length, dead_workers.size].min.times do |i|
                    job,dir = dead_workers.pop
                    $workers.delete(job)
                    id = File.basename(dir)
                    if id =~ /worker(\d+)/ then
                        id = $1
                    else
                        id = id[$binary_name.length+1,id.length-$binary_name.length-1]
                    end
                    FileUtils.rm_rf(dir)
                    Dir.mkdir(dir)
                    job = fork do
                        exec "cd #{dir} && #{$self_invoke} worker #{id} #{$search_path}"
                    end
                    #puts "Respawned worker thread #{id} (pid=#{job})."
                    $workers[job] = dir
                end
            end

            # wait a while
            sleep 5
        end

        # clean up any workers and directories
        $workers.each_pair do |job, dir|
            begin
                Process.wait(job.to_i)
            rescue
            end
            FileUtils.rm_rf(dir)
        end

        # if the workqueue is empty and all the workers are dead but there
        # are still configs in the inproc queue, then something was aborted;
        # move any unfinished configs back to the workqueue and restart
        if get_inproc_length > 0 then
            puts "Unfinished jobs; restarting workers ..."
            move_all_inproc_to_workqueue
        end
    end
end # }}}
# {{{ finalize_search
def finalize_search

    if File.exist?($final_path) then
        # another process is already finalizing
        puts "Finalization already underway."
        return
    else
        Dir.mkdir($final_path)
    end

    # queue status output
    puts ""
    puts "Candidate queue exhausted.  [Max queue length: ~#{$max_queue_length} item(s)]"

    # generate final config file
    print "Generating final configuration ... "
    $stdout.flush
    rebuild_final_config
    FileUtils.cp($final_config_fn, $final_path)
    puts "done."

    # try the final config (and keep results)
    puts "Testing final configuration ... "
    Dir.chdir($final_path)
    run_config_file($final_config_fn, true, $final_config.cuid)
    Dir.chdir($search_path)

    # start generating final report
    report = build_best_report(10, true)

    # finalize report
    elapsed = Time.now.to_f - $start_time.to_f
    summary = get_tested_configs_summary
    report << "Total configs tested:      #{"%11d" % summary["total"]}"
    report << "  Total passed:            #{"%11d" % summary["pass"]}"
    report << "  Total failed:            #{"%11d" % summary["fail"]}"
    report << "  Total aborted:           #{"%11d" % summary["error"]}"
    report << "Done.  [Total elapsed walltime: #{format_time(elapsed)}]"
    report << " "
    add_to_mainlog(report.join("\n"))
    puts report.join("\n")

    # wtf = wall time file
    # what did *you* think it meant?!?!?
    #
    wtf = File.new($walltime_fn,"w")
    wtf.puts elapsed.to_s
    wtf.close

end # }}}


# Helper routines

# {{{ initialization


def read_craft_driver
    IO.foreach("#{$search_path}#{$craft_driver}") do |line|
        if line =~ /^#\s*BINARY\s*=\s*(.*)/ then
            $binary_name = File.basename($1)
            $binary_path = File.expand_path($1)
        elsif line =~ /^#\s*NUM_WORKERS\s*=\s*(\d+)/ then
            $num_workers = $1.to_i
        elsif line =~ /^#\s*DEBUG_MODE\s*=\s*(\w+)/ then
            if $1 == "single" then
                $status_preferred = $STATUS_SINGLE
                $status_alternate = $STATUS_IGNORE
            elsif $1 == "double" then
                $status_preferred = $STATUS_DOUBLE
                $status_alternate = $STATUS_IGNORE
            end
        elsif line =~ /^#\s*INITIAL_CFG\s*=\s*(\w+)/ then
            $initial_cfg_fn = $1
        elsif line =~ /^#\s*FORTRAN_MODE\s*=\s*(\w+)/ then
            if $1 == "yes" then
                $fortran_mode = true
            end
        elsif line =~ /^#\s*BASE_TYPE\s*=\s*(\w*)/ then
            type = $1.chomp.downcase
            if type =~ /ins/ then
                $base_type = $TYPE_INSTRUCTION
            elsif type =~ /block/ then
                $base_type = $TYPE_BASICBLOCK
            elsif type =~ /func/ then
                $base_type = $TYPE_FUNCTION
            elsif type =~ /mod/ then
                $base_type = $TYPE_MODULE
            elsif type =~ /app/ then
                $base_type = $TYPE_APPLICATION
            end
        elsif line =~ /^#\s*SEARCH_STRAT\s*=\s*(\w+)/ then
            if not ($1 == "default") then
                $strategy_name = $1
            end
        end
    end
end


def parse_command_line
    $main_mode = ARGV.shift.strip.downcase
    if $main_mode == "search" then
        $main_mode = "start"
    end
    if not ["start","resume","worker","status","help","clean"].include?($main_mode) then
        puts "Invalid mode: #{$main_mode}"
        exit
    end
    if $main_mode == "worker" then
        $worker_id = ARGV.shift
        $search_path = ARGV.shift
    end
    parsed_binary = false
    while ARGV.size > 0 do
        opt = ARGV.shift
        if $main_mode == "start" then
            if opt == "-j" then
                # parallel: "-j 4" variant
                $num_workers = ARGV.shift.to_i
            elsif opt =~ /^-j/ then
                # parallel: "-j4" variant
                $num_workers = opt[2,opt.length-2].to_i
            elsif opt == "-d" then
                # debug mode (double precision)
                $status_preferred = $STATUS_DOUBLE
                $status_alternate = $STATUS_IGNORE
            elsif opt == "-D" then
                # debug mode (single precision)
                $status_preferred = $STATUS_SINGLE
                $status_alternate = $STATUS_IGNORE
            elsif opt == "-c" then
                # initial configuration
                $initial_cfg_fn = ARGV.shift
            elsif opt == '-m' then
                # memory-based analysis
                $fpconf_options += "-m "
            elsif opt == '-N' then
                # fortran mode
                $fortran_mode = true
            elsif opt == '-b' then
                # stop splitting at basic blocks
                $base_type = $TYPE_BASICBLOCK
            elsif opt == '-f' then
                # stop splitting at functions
                $base_type = $TYPE_FUNCTION
            elsif opt == '-s' then
                # strategy
                $strategy_name = ARGV.shift
            elsif !parsed_binary then
                $binary_name = File.basename(opt)
                $binary_path = File.expand_path(opt)
                parsed_binary = true
            else
                if parsed_binary then
                    puts "Invalid parameter after binary: #{opt}"
                    exit
                else
                    puts "Invalid resume parameter: #{opt}"
                    exit
                end
            end
        elsif $main_mode == "resume" then
            if opt == "-j" then
                # parallel: "-j 4" variant
                $num_workers = ARGV.shift.to_i
            elsif opt =~ /^-j/ then
                # parallel: "-j4" variant
                $num_workers = opt[2,opt.length-2].to_i
            elsif opt == "-l" then
                $resume_lower = true
            elsif opt == "-n" then
                $restart_inproc = true
            else
                puts "Invalid resume option: #{opt}"
                exit
            end
        else
            puts "Invalid parameter: #{opt}"
            exit
        end
    end
    if $main_mode == "start" and !parsed_binary then
        puts "No binary included on command-line."
        exit
    end
end


def initialize_program
    $program = nil
    mod = nil
    func = nil
    bblk = nil
    prolog = ""
    IO.foreach($orig_config_fn) do |line|
        if line =~ /(APPLICATION #\d+: [x0-9A-Fa-f]+) \"(.+)\"/ then
            $program = PPoint.new($1, $TYPE_APPLICATION, line[1,1])
            $program.attrs["desc"] = $2
        elsif line =~ /(MODULE #\d+: 0x[0-9A-Fa-f]+) \"(.+)\"/ then
            mod = PPoint.new($1, $TYPE_MODULE, line[1,1])
            mod.attrs["desc"] = $2
            $program.children << mod if $program != nil
        elsif line =~ /(FUNC #\d+: 0x[0-9A-Fa-f]+) \"(.+)\"/ then
            func = PPoint.new($1, $TYPE_FUNCTION, line[1,1])
            func.attrs["desc"] = $2
            mod.children << func if mod != nil
        elsif line =~ /(BBLK #\d+: (0x[0-9A-Fa-f]+))/ then
            bblk = PPoint.new($1, $TYPE_BASICBLOCK, line[1,1])
            bblk.attrs["addr"] = $2
            func.children << bblk if func != nil
        elsif line =~ /(INSN #\d+: (0x[0-9A-Fa-f]+)) \"(.+)\"/ then
            insn = PPoint.new($1, $TYPE_INSTRUCTION, line[1,1])
            insn.attrs["addr"] = $2
            insn.attrs["desc"] = $3
            bblk.children << insn if bblk != nil
        else
            prolog << line.chomp
            prolog << "\n"
        end
    end
    $program.build_lookup_hash if $program != nil
    $program.attrs["prolog"] = prolog
    if $program.nil? then
        puts "Unable to initialize program control structure."
        puts "Aborting search."
        exit
    end
end

def initialize_strategy
    if $strategy_name == "simple" then
        $strategy = Strategy.new($program, $status_preferred, $status_alternate)
    elsif $strategy_name == "bin_simple" then
        $strategy = BinaryStrategy.new($program, $status_preferred, $status_alternate)
        $strategy.basetype = $base_type
    else
        puts "Unrecognized search strategy \"#{$strategy_name}\""
        puts "Aborting search."
        exit
    end
end


def run_baseline_performance
    passed = false
    if not File.exist?($perf_path) then
        Dir.mkdir($perf_path)
    end
    Dir.chdir($perf_path)
    $baseline_error = 0.0
    $baseline_runtime = 0
    cmd = "#{$search_path}#{$craft_driver} #{$binary_path}"
    io_in, io_out, io_err = Open3.popen3(cmd)
    io_err.each_line do |line| end
    io_out.each_line do |line|
        if line =~ /status:\s*(pass|fail)/i then
            if $1 =~ /pass/i then
                passed = true
            end
        end
        if line =~ /error:\s*(.+)/i then
            $baseline_error = $1.to_f
        end
        if line =~ /time:\s*(.+)/i then
            $baseline_runtime = $1.to_i
        end
    end
    Dir.chdir($search_path)
    return passed
end


def run_profiler
    passed = false
    if not File.exist?($prof_path) then
        Dir.mkdir($prof_path)
    end
    Dir.chdir($prof_path)

    # run mutator
    cmd = "#{$fpinst_invoke} -i --cinst #{$binary_path}"
    io_in, io_out, io_err = Open3.popen3(cmd)
    io_err.each_line do |line| end
    io_out.each_line do |line| end

    # run rewritten mutatee
    cmd = "#{$search_path}#{$craft_driver} #{Dir.getwd}/mutant"
    io_in, io_out, io_err = Open3.popen3(cmd)
    io_err.each_line do |line| end
    io_out.each_line do |line|
        if line =~ /status:\s*(pass|fail)/i then
            if $1 =~ /pass/i then
                passed = true
            end
        end
    end

    # extract log file name
    if passed then
        $perf_log_fn = "#{Dir.getwd}/#{Dir.glob("*-c_inst*.log").first}"
    end

    Dir.chdir($search_path)
    return passed
end


def read_profiler_data
    pt_by_id = Hash.new

    # read individual instruction counts from log file

    # pass 1: extract ID => point mappings
    IO.foreach($perf_log_fn) do |line|
        if line =~ /instruction id="(\d+)" address="([x0-9a-zA-Z]+)"/ then
            pt_by_id[$1] = $program.lookup_by_addr($2)
        end
    end

    # pass 2: read counts
    cur_count = ""
    IO.foreach($perf_log_fn) do |line|
        if line =~ /priority="(\d+)" type="InstCount"/ then
            cur_count = $1
        end
        if line=~ /<inst_id>(\d+)<\/inst_id>/ then
            cur_id = $1
            cur_pt = pt_by_id[cur_id]
            if not cur_pt.nil? and cur_pt.orig_status == $STATUS_CANDIDATE then
                # only count candidates
                cur_pt.attrs["cinst"] = cur_count
            end
        end
    end

    # propogate instruction counts up to the root
    update_cinst($program)
end

def update_cinst (pt)
    if not pt.attrs.has_key?("cinst") then
        total_cinst = 0
        pt.children.each do |child|
            update_cinst(child)
            total_cinst += child.attrs["cinst"].to_i
        end
        pt.attrs["cinst"] = total_cinst.to_s
    end
end


# }}}
# {{{ configuration testing


def calculate_orig_stats (cfg)
    orig_icount = 0
    orig_cinst = 0
    cfg.exceptions.keys.each do |k|
        pt = $program.lookup_by_uid(k)
        if !pt.nil? then
            orig_icount += pt.attrs["icount"].to_i
            orig_cinst += pt.attrs["cinst"].to_i
            if cfg.exceptions.keys.size == 1 then
                cfg.attrs["single_type"] = pt.type
            end
        end
    end
    orig_icount = (orig_icount.to_f / $program.attrs["icount"].to_f * 100.0).to_s
    orig_cinst = (orig_cinst.to_f / $program.attrs["cinst"].to_f * 100.0).to_s
    cfg.attrs["orig_icount"] = orig_icount.to_s
    cfg.attrs["orig_cinst"] = orig_cinst.to_s
end

def run_config (cfg)

    # write actual configuration file
    cfg_path = $search_path + cfg.filename
    $program.build_config_file(cfg, cfg_path)

    # pass off to filename version
    result,error,runtime = run_config_file(cfg_path, false, cfg.cuid)

    # save result
    cfg.attrs["result"] = result
    cfg.attrs["error"] = error
    cfg.attrs["runtime"] = runtime

    # delete actual configuration file
    FileUtils.rm_rf(cfg_path)

    return result
end

def run_config_file (fn, keep, cuid)

    # status updates
    basename = File.basename(fn)
    if basename =~ /^#{$binary_name}(.*)/ then
        basename = $1
    end
    #puts "  Testing #{basename} ..."
    $status_buffer = "    Finished testing #{cuid}:\n"

    # build rewritten mutatee
    cmd = "#{$fpinst_invoke} -i #{$fortran_mode ? "-N" : ""}"
    cmd += " -c #{fn}"
    cmd += " #{$binary_path}"
    #add_to_mainlog("    Building mutatee for #{basename}: #{cmd}")
    io_in, io_out, io_err = Open3.popen3(cmd)
    io_err.each_line do |line| end
    io_out.each_line do |line|
        if line =~ /Inplace: (.*)$/ then
            $status_buffer += "        #{$1}\n"
        end
    end

    # execute rewritten mutatee and check for success
    result = $RESULT_ERROR
    runtime = 0
    error = 0.0
    cmd = "#{$search_path}#{$craft_driver} #{Dir.getwd}/mutant"
    #add_to_mainlog("    Testing mutatee for #{basename}: #{cmd}")
    io_in, io_out, io_err = Open3.popen3(cmd)
    io_err.each_line do |line| end
    io_out.each_line do |line|
        if line =~ /status:\s*(pass|fail)/i then
            tmp = $1
            if tmp =~ /pass/i then
                result = $RESULT_PASS
            elsif tmp =~ /fail/i then
                result = $RESULT_FAIL
            end
        elsif line =~ /error:\s*(.+)/i then
            error = $1.to_f
        elsif line =~ /time:\s*(.+)/i then
            runtime = $1.to_i
        end
    end

    # scan log file(s) for info
    Dir.glob("*.log").each do |lfn|
        if lfn != "fpinst.log" then
            IO.foreach(lfn) do |line|
                if line =~ /Inplace: (.*)$/ then
                    $status_buffer += "        #{$1.gsub(/<.*>/, "")}\n"
                end
            end
        end
    end

    # print output
    $status_buffer += "        #{result}"
    $status_buffer += "  [Walltime: #{format_time(runtime.to_f)}"
    $status_buffer += " %.1fX"%[runtime / $baseline_runtime.to_f]
    $status_buffer += " Error: %g]"%[error]
    puts $status_buffer
    add_to_mainlog($status_buffer)
    if keep then
        f = File.new("result.txt", "w")
        f.puts $status_buffer
        f.close
    end
    $status_buffer = ""

    # copy config to appropriate folder
    if result == $RESULT_PASS then
        FileUtils.cp(fn, $passed_path)
    elsif result == $RESULT_FAIL then
        FileUtils.cp(fn, $failed_path)
    elsif result == $RESULT_ERROR then
        FileUtils.cp(fn, $aborted_path)
    end

    # clean out mutant, logs, and rewritten library files
    if !keep then
        begin
            toDelete = Array.new
            Dir.glob("*").each do |lfn|
                toDelete << lfn
                #if lfn =~ /mutant/ || lfn =~ /\.log/ || lfn =~ /lib(c|m)\.so\.6/ then
                #if lfn =~ /mutant/ || lfn =~ /\.log/ || lfn =~ /\.so$/ then
                    #File.delete(lfn)
                #end
            end
            toDelete.each do |fn|
                File.delete(fn)
            end
        rescue
            puts "Error clearing old files"
        end
    end

    return [result,error,runtime]
end


# }}}
# {{{ file manipulation


# FOR THE SYSTEM TO WORK, ALL OF THESE I/O ROUTINES *MUST* BE ATOMIC!
# None should be able to interrupt or starve another. This means that
# we need to lock the file in each function, and no function should
# call another.


def save_settings
    f = File.new($settings_fn, "r+")
    f.flock File::LOCK_EX
    f.truncate(0)
    f.puts $start_time.to_i
    f.puts $binary_name
    f.puts $binary_path
    f.puts $strategy_name
    f.puts $stat_preferred
    f.puts $stat_alternate
    f.puts $baseline_runtime
    f.puts($fortran_mode ? "fortran" : "other")
    f.puts $base_type
    f.puts $initial_cfg_fn
    f.puts $perf_log_fn
    f.close
end
def load_settings
    f = File.new($settings_fn, "r")
    f.flock File::LOCK_SH
    $start_time = Time.at(f.gets.to_i)
    $binary_name = f.gets.chomp
    $binary_path = f.gets.chomp
    $strategy_name = f.gets.chomp
    $stat_preferred = f.gets.chomp
    $stat_alternate = f.gets.chomp
    $baseline_runtime = f.gets.chomp.to_i
    lang = f.gets.chomp
    if lang == "fortran" then
        $fortran_mode = true
    else
        $fortran_mode = false
    end
    $base_type = f.gets.chomp
    $initial_cfg_fn = f.gets.chomp
    $perf_log_fn = f.gets.chomp
    f.close
end


def add_to_workqueue(cfg)
    calculate_orig_stats(cfg)

    queue = Array.new
    f = File.new("#{$workqueue_fn}", "r+")
    f.flock File::LOCK_EX
    YAML.each_document(f) do |doc|
        queue << doc
    end

    queue << cfg
    queue.sort!
    
    # debug output
    #puts "Current workqueue:"
    #queue.each do |c|
        #puts "  - #{c.label}"
    #end
    
    f.truncate(0)
    f.pos = 0
    queue.each do |cfg|
        YAML.dump(cfg, f)
    end
    f.close
end
def get_next_workqueue_item
    next_cfg = nil
    queue = Array.new
    f = File.new($workqueue_fn, "r+")
    f.flock File::LOCK_EX
    YAML.each_document(f) do |doc|
        queue << doc
    end
    next_cfg = queue.shift
    f.pos = 0
    queue.each do |cfg|
        YAML.dump(cfg, f)
    end
    f.truncate(f.pos)
    f.close
    return next_cfg
end
def get_workqueue_configs
    queue = Array.new
    f = File.new("#{$workqueue_fn}", "r")
    f.flock File::LOCK_SH
    YAML.each_document(f) do |doc|
        queue << doc
    end
    f.close
    return queue
end
def get_workqueue_length
    len = 0
    f = File.new($workqueue_fn, "r")
    f.flock File::LOCK_SH
    YAML.each_document(f) do |doc|
        len += 1
    end
    f.close
    return len
end


def add_to_inproc(cfg)
    f = File.new($inproc_fn, "a")
    f.flock File::LOCK_EX
    YAML.dump(cfg, f)
    f.close
end
def remove_from_inproc(cfg)
    inproc = Array.new
    f = File.new($inproc_fn, "r+")
    f.flock File::LOCK_EX
    YAML.each_document(f) do |doc|
        inproc << doc if not (cfg.cuid == doc.cuid)
    end
    f.pos = 0
    inproc.each do |cfg|
        YAML.dump(cfg, f)
    end
    f.truncate(f.pos)
    f.close
end
def get_inproc_configs
    inproc = Array.new
    f = File.new("#{$inproc_fn}", "r")
    f.flock File::LOCK_SH
    YAML.each_document(f) do |doc|
        inproc << doc
    end
    f.close
    return inproc
end
def get_inproc_length
    len = 0
    f = File.new($inproc_fn, "r")
    f.flock File::LOCK_SH
    YAML.each_document(f) do |doc|
        len += 1
    end
    f.close
    return len
end
def move_all_inproc_to_workqueue
    f = File.new($inproc_fn, "r+")
    f.flock File::LOCK_EX
    YAML.each_document(f) do |doc|
        add_to_workqueue(doc)
    end
    f.truncate(0)
    f.close
end


def add_tested_config(cfg)
    f = File.new("#{$tested_fn}", "a")
    f.flock File::LOCK_EX
    YAML.dump(cfg, f)
    f.close
end
def get_tested_configs
    tested = Array.new
    f = File.new("#{$tested_fn}", "r")
    f.flock File::LOCK_SH
    YAML.each_document(f) do |doc|
        tested << doc
    end
    f.close
    return tested
end
def get_tested_config_count
    len = 0
    f = File.new("#{$tested_fn}", "r")
    f.flock File::LOCK_SH
    YAML.each_document(f) do |doc|
        len += 1
    end
    f.close
    return len
end


def add_to_mainlog(reg)
    f = File.new($mainlog_fn, "a")
    f.flock File::LOCK_EX
    f.puts(reg.to_s)
    f.close
end
def load_mainlog
    f = File.new($mainlog_fn, "r")
    f.flock File::LOCK_SH
    lines = f.readlines
    f.close
    return lines
end


# }}}
# {{{ output


def print_usage
    puts " "
    puts "Usage:  #{$self_invoke} start [start-options] <binary>    (supervisor process)"
    puts "          or"
    puts "        #{$self_invoke} resume [resume-options]           (resume supervisor process)"
    puts "          or"
    puts "        #{$self_invoke} status                            (display search status)"
    puts "          or"
    puts "        #{$self_invoke} clean                             (reset search)"
    puts "          or"
    puts "        #{$self_invoke} worker <id> <dir>                 (worker process; used internally)"
    puts " "
    puts "Valid initial options:"
    puts "   -b             stop splitting configs at the basic block level"
    puts "   -c <file>      use <file> as initial base configuration"
    puts "   -d             debug mode (ignore->double instead of double->single)"
    puts "   -D             debug mode (ignore->single instead of double->single)"
    puts "   -f             stop splitting configs at the function level"
    puts "   -j <np>        spawn <np> worker threads"
    puts "   -m             memory-based analysis"
    puts "   -N             enable Fortran mode (passes \"-N\" to fpinst)"
    puts "   -s <name>      use <name> strategy (default is \"bin_simple\")"
    puts "                    valid strategies:  \"simple\" and \"bin_simple\""
    puts " "
    puts "Valid resumption options:"
    puts "   -j <np>        spawn <np> worker threads"
    puts "   -l             resume search at lower level (e.g., INSN instead of BBLK)"
    puts "   -n             resume search and restart in-process tests"
    puts " "
end


def get_worker_thread_count
    cmd = "ps -C #{$self_invoke} -o s="
    psr = `#{cmd}`
    num_workers = [0,psr.lines.count - ($main_mode == "status" ? 2 : 1)].max
    return num_workers
end


def get_status
    overall_status = "not running"
    if File.exist?($settings_fn) then
        begin
            load_settings
            overall_status = "initializing"
            overall_status = "waiting" if File.exist?($workqueue_fn)
            overall_status = "running" if (get_workqueue_length > 0 or get_inproc_length > 0)
            overall_status = "finalizing" if File.exist?($final_path)
            overall_status = "DONE" if File.exist?($walltime_fn)
        rescue
            overall_status = "initializing"
        end
    end
    return overall_status
end


def print_status

    hbar   = "===================================================================================================="
    indent = "                            "
    ptag = Time.now.strftime("%Y-%m-%d %H:%M:%S %z")
    ftag = Time.now.strftime("status_%Y_%m_%d_%H_%M_%S_%z.txt")
    overall_status = get_status     # calls load_settings
    full_output = (overall_status == "waiting" or overall_status == "running" or
                   overall_status == "finalizing" or overall_status == "DONE")
    nworkers = get_worker_thread_count

    status_text = Array.new
    status_text << "Snapshot taken at #{ptag}"
    status_text << " "
    status_text << hbar
    status_text << "#{indent}                  CRAFT"

    # basic statistics (app, config count, queue size, etc.)
    if full_output then
        elapsed = Time.now.to_f - $start_time.to_f
        if File.exist?($walltime_fn) then
            elapsed = IO.readlines($walltime_fn)[0].to_f
        end
        status_text << "#{indent}Application: #{"%27s" % $binary_name}"
        #status_text << "#{indent}Fortran mode:  #{"%24s" % ($fortran_mode ? "Y" : "N")}"
        status_text << "#{indent}Base type:  #{"%28s" % $base_type}"
        status_text << "#{indent}Worker threads:            #{"%13d" % nworkers}"
        summary = get_tested_configs_summary
        status_text << "#{indent}Total configs tested:      #{"%13d" % summary["total"]}"
        status_text << "#{indent}   Total passed:           #{"%13d" % summary["pass"]}"
        status_text << "#{indent}   Total failed:           #{"%13d" % summary["fail"]}"
        status_text << "#{indent}   Total aborted:          #{"%13d" % summary["error"]}"
        status_text << "#{indent}Current in-proc length:    #{"%13d" % get_inproc_length}"
        status_text << "#{indent}Current workqueue length:  #{"%13d" % get_workqueue_length}"
        status_text << "#{indent}Total elapsed walltime: #{"%16s" % format_time(elapsed)}"
    end
    status_text << "#{indent}Overall status:         #{"%16s" % overall_status}"
    status_text << hbar

    # best results so far and current in-process configs
    if full_output then
        build_best_report(8).each do |rl|
            status_text << rl
        end
        status_text << hbar
        if get_inproc_length > 0 or get_workqueue_length > 0 then
            inproc = get_inproc_configs
            queue = get_workqueue_configs
            status_text << ""
            progress = "Current workqueue (" + (queue.size > inproc.size ? inproc.size : queue.size).to_s + "/" + queue.size.to_s + "):"
            status_text << "  Currently testing:                  STA\%   DYN\%   #{"%-33s"%progress}   STA\%   DYN\%"
            0.upto(inproc.size-1) do |i|
                line = ""
                if i < inproc.size then
                    icfg = inproc[i]
                    line += "    - %-30s %5.1f  %5.1f "%[format_text(icfg.cuid,30),icfg.attrs["orig_icount"],icfg.attrs["orig_cinst"]]
                else
                    line += "%50s"%" "
                end
                if i < queue.size then
                    qcfg = queue[i]
                    line += "    - %-30s %5.1f  %5.1f "%[format_text(qcfg.cuid,30),qcfg.attrs["orig_icount"],qcfg.attrs["orig_cinst"]]
                end
                status_text << line if line.strip != ""
            end
            if queue.size > inproc.size then
                status_text << "%50s      ..."%" "
            end
            status_text << ""
            status_text << hbar
        end
    end

    # print to stdout
    puts status_text

    # create snapshot file
    if !File.exist?($snapshot_path) then
        Dir.mkdir($snapshot_path)
    end
    f = File.new("#{$snapshot_path}#{ftag}", "w")
    f.puts status_text
    f.close

    # remove latest snapshot if it's a duplicate of the previous one
    all_snapshots = Dir.glob("#{$snapshot_path}status*.txt").sort { |f1,f2| File.mtime(f2) <=> File.mtime(f1) }
    if all_snapshots.size > 1 then
        newest_fn = all_snapshots.at(0)
        older_fn = all_snapshots.at(1)
        diff = `diff #{older_fn} #{newest_fn}`.split("\n")

        # 2 always-changing snapshot lines (timestamp + elapse walltime)
        # 4 diff lines per snapshot line (assumes default diff output)
        if diff.size <= 2*4 then
            File.delete(newest_fn)
        end
    end
end


def format_time (elapsed)
    mins, secs = elapsed.divmod 60.0
    hrs, mins = mins.divmod 60.0
    #return "%d:%02d:%05.2f"%[hrs.to_i, mins.to_i, secs]
    return "%d:%02d:%02d"%[hrs.to_i, mins.to_i, secs.to_i]
end


def format_text (str, width)
    if str.size > width then
        str = str[0,width-3] + "..."
    end
    return str
end


# }}}
# {{{ finalization and cleanup


def rebuild_final_config
    $final_config = $strategy.build_final_config(get_tested_configs)
    $program.build_config_file($final_config, $final_config_fn)
    calculate_orig_stats($final_config)
end


def is_single_base (cfg, type)
    isb = false
    if cfg.exceptions.keys.size == 1 then
        pt = $program.lookup_by_uid(cfg.exceptions.keys.first)
        if !pt.nil? and pt.type == type then
            isb = true
        end
    end
    return isb
end


def build_best_report(num,copy_files=false)
    # find best individual configs
    results = get_tested_configs
    inst_passed_cfgs = Array.new
    exec_passed_cfgs = Array.new
    exec_passed_cfgs = Array.new
    inst_passed = 0.0
    exec_passed = 0.0
    inst_failed_cfgs = Array.new
    exec_failed_cfgs = Array.new
    inst_failed = 0.0
    exec_failed = 0.0
    results.each do |cfg|
        if not (cfg.cuid == $FINALCFG_CUID) then
            if cfg.attrs["result"] == $RESULT_PASS then
                inst_passed_cfgs << [cfg, cfg.attrs["orig_icount"].to_f]
                exec_passed_cfgs << [cfg, cfg.attrs["orig_cinst"].to_f]
                inst_passed += cfg.attrs["orig_icount"].to_f
                exec_passed += cfg.attrs["orig_cinst"].to_f
            else
                if cfg.attrs.has_key?("single_type") and cfg.attrs["single_type"] == $base_type then
                    inst_failed_cfgs << [cfg, cfg.attrs["orig_icount"].to_f]
                    exec_failed_cfgs << [cfg, cfg.attrs["orig_cinst"].to_f]
                    inst_failed += cfg.attrs["orig_icount"].to_f
                    exec_failed += cfg.attrs["orig_cinst"].to_f
                end
            end
        end
    end
    report = Array.new
    report << " "
    report << "  Top instrumented (passed):                STA\%    Top instrumented (failed/aborted):        STA\%"
    inst_passed_cfgs = inst_passed_cfgs.sort_by { |cfg,pct| -pct }
    inst_failed_cfgs = inst_failed_cfgs.sort_by { |cfg,pct| -pct }
    0.upto(num-1).each do |i|
        line = ""
        if i < inst_passed_cfgs.size then
            pcfg,ppct = inst_passed_cfgs[i]
            FileUtils.cp($passed_path + pcfg.filename, $best_path) if copy_files
            line += "    - %-35s  %5.1f  "%[format_text(pcfg.cuid,35),ppct]
        else
            line += "%50s"%" "
        end
        if i < inst_failed_cfgs.size then
            fcfg,fpct = inst_failed_cfgs[i]
            line += "    - %-35s  %5.1f  "%[format_text(fcfg.cuid,35),fpct]
        end
        report << line if line.strip != ""
    end
    report << " "
    report << "      %35s  %5.1f  "%["TOTAL PASSED",inst_passed] +
              "      %35s  %5.1f  "%["TOTAL FAILED",inst_failed]
    report << "%50s      %35s  %5.1f"%[" ","TOTAL",inst_passed+inst_failed]
    report << " "
    report << "  Top executed (passed):                    DYN\%    Top executed (failed/aborted):            DYN\%"
    exec_passed_cfgs = exec_passed_cfgs.sort_by { |cfg,pct| -pct }
    exec_failed_cfgs = exec_failed_cfgs.sort_by { |cfg,pct| -pct }
    0.upto(num-1).each do |i|
        line = ""
        if i < exec_passed_cfgs.size then
            pcfg,ppct = exec_passed_cfgs[i]
            FileUtils.cp($passed_path + pcfg.filename, $best_path) if copy_files
            line += "    - %-35s  %5.1f  "%[format_text(pcfg.cuid,35),ppct]
        else
            line += "%50s"%" " 
        end
        if i < exec_failed_cfgs.size then
            fcfg,fpct = exec_failed_cfgs[i]
            line += "    - %-35s  %5.1f  "%[format_text(fcfg.cuid,35),fpct]
        end
        report << line if line.strip != ""
    end
    report << " "
    report << "      %35s  %5.1f  "%["TOTAL PASSED",exec_passed] +
              "      %35s  %5.1f  "%["TOTAL FAILED",exec_failed]
    report << "%50s      %35s  %5.1f"%[" ","TOTAL",exec_passed+exec_failed]
    report << " "
    return report
end

def get_tested_configs_summary
    summary = Hash.new(0)
    tested_cfgs = get_tested_configs
    tested_cfgs.each do |cfg|
        if cfg.attrs.has_key?("result") then
            if cfg.attrs["result"] == $RESULT_PASS then
                summary["pass"] += 1
            elsif cfg.attrs["result"] == $RESULT_FAIL then
                summary["fail"] += 1
            elsif cfg.attrs["result"] == $RESULT_ERROR then
                summary["error"] += 1
            end
        end
    end
    summary["total"] = tested_cfgs.size
    return summary
end


def clean_everything
    toDelete = Array.new
    Dir.glob("#{$search_tag}.*") do |fn| toDelete << fn end
    Dir.glob("*_worker*") do |fn| toDelete << fn end
    Dir.glob("*.cfg") do |fn| toDelete << fn end
    Dir.glob("*.log") do |fn| toDelete << fn end
    Dir.glob("baseline") do |fn| toDelete << fn end
    Dir.glob("profile") do |fn| toDelete << fn end
    Dir.glob("final") do |fn| toDelete << fn end
    Dir.glob("best") do |fn| toDelete << fn end
    Dir.glob("passed") do |fn| toDelete << fn end
    Dir.glob("failed") do |fn| toDelete << fn end
    Dir.glob("aborted") do |fn| toDelete << fn end
    Dir.glob("snapshots") do |fn| toDelete << fn end
    toDelete.each do |fn|
        FileUtils.rm_rf(fn)
    end
end


# }}}


# top-level: call main
main

